<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".generated.cs" #>
// <auto-generated> This file has been auto generated. </auto-generated>
//#nullable enable
using System;
using System.Collections.Generic;

namespace LinqToDB.Internal.Common
{
<#
	var MaxMemberCount = 10;
	var prefixes = new[] { "M" };
#>
	internal static partial class MutableTuple
	{
		public const int MaxMemberCount = <#= MaxMemberCount #>;

<#
	foreach (var prefix in prefixes)
	{
#>
		public static readonly Type[] <#= prefix #>Types = new []
		{
<#
	    foreach (var info in Enumerable.Range(1, MaxMemberCount))
	    {
	        var indexes = Enumerable.Range(1, info).ToArray();
	        var types = string.Join(",", indexes.Select(i => ""));
#>
			typeof(<#= prefix #>Tuple<<#= types #>>),
<#
	    } #>
		};

<#
	}
#>
		internal static int CombineHashCodes(int h1, int h2)
		{
			return (((h1 << 5) + h1) ^ h2);
		}
<#
	for (var info = 3; info <= MaxMemberCount; info++)
	{
		var leftSide           = (info + 1) / 2;
		var rightSide          = info - leftSide;
		var leftNames          = Enumerable.Range(1, leftSide);
		var rightNames         = Enumerable.Range(leftSide + 1, rightSide);
		var allNames           = Enumerable.Range(1, info);
		var leftCallArguments  = string.Join(", ", leftNames.Select(i => $"h{i}"));
		var rightCallArguments = string.Join(", ", rightNames.Select(i => $"h{i}"));
		var allParameters      = string.Join(", ", allNames.Select(i => $"int h{i}"));
		var leftCall           = $"CombineHashCodes({leftCallArguments})";
		string rightCall;
		if (rightSide == 1)
			rightCall = rightCallArguments;
		else
			rightCall = $"CombineHashCodes({rightCallArguments})";
		var callStr = $"CombineHashCodes({leftCall}, {rightCall})";
#>
		internal static int CombineHashCodes(<#= allParameters #>)
			=> <#= callStr #>;

<#
	}#>
	}

<#
	foreach (var prefix in prefixes)
	foreach (var info in Enumerable.Range(1, MaxMemberCount))
	{

		var indexes      = Enumerable.Range(1, info).ToArray();
		var types        = string.Join(", ", indexes.Select(i => "T" + i.ToString()));
		var equals       = string.Join("\r\n\t\t\t\t&& ", indexes.Select(i => $"_item{i}ValueComparer.Equals(Item{i}, objTuple.Item{i})"));
		var hashCodes    = string.Join(",\r\n\t\t\t\t", indexes.Select(i => $"_item{i}ValueComparer.GetHashCode(Item{i})"));
		var hashCodesStr = hashCodes;
		if (info > 1)
		    hashCodesStr = $"MutableTuple.CombineHashCodes({hashCodes})";

#>
	internal class <#= prefix #>Tuple<<#= types #>>
	{
<#
	foreach (var idx in indexes)
	{
#>
		public T<#= idx #> Item<#= idx #> { get; set; }
<#
	}
#>
<#
	foreach (var idx in indexes)
	{
#>
		static IEqualityComparer<T<#= idx #>> _item<#= idx #>ValueComparer = ValueComparer.GetDefaultValueComparer<T<#= idx #>>(true);
<#
	}
#>
		public override bool Equals(object other)
		{
			if (other == null) return false;

			var objTuple = other as MTuple<<#= types #>>;

			if (objTuple == null)
				return false;

			return <#= equals #>;
		}

		public override int GetHashCode()
			=> <#= hashCodesStr #>;
	}
<#
	}
#>
}
