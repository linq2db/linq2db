using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

using LinqToDB;
using LinqToDB.Expressions;
using LinqToDB.Extensions;
using LinqToDB.Internal.Common;
using LinqToDB.Internal.Expressions;
using LinqToDB.Internal.Extensions;
using LinqToDB.Mapping;

namespace LinqToDB.Internal.Linq.Builder
{
	sealed class ExpressionTestGenerator : ExpressionVisitorBase
	{
		private const string TEMPLATE = @"//---------------------------------------------------------------------------------------------------
// This code was generated by LinqToDB.
//---------------------------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Linq.Expressions;
using LinqToDB;
using NUnit.Framework;

{0}
namespace Tests.UserTests
{{
	[TestFixture]
	public class UserTest : TestBase
	{{
		[Test]
		public void Test([DataSources(ProviderName.SQLite)] string context)
		{{
			// {1}
			using (var db = GetDataContext(context))
			{{
				{2};
			}}
		}}
	}}
}}
";

		static List<string> SystemNamespaces = [ "System", "LinqToDB", "Microsoft" ];

		static readonly ObjectPool<ExpressionTestGenerator> Pool = new(() => new ExpressionTestGenerator(), v => v.Cleanup(), 100);

		string?                   _indent;
		bool                      _mangleNames;
		IDataContext?             _dataContext;
		StringBuilder             _exprBuilder  = default!;
		HashSet<Type>?            _usedTypes;
		HashSet<object>           _usedMembers  = default!;
		StringBuilder             _typeBuilder  = default!;
		Dictionary<string,string> _nameDic      = default!;
		Dictionary<Type,string?>  _typeNames    = default!;
		HashSet<Expression>       _visitedExprs = default!;

		public override void Cleanup()
		{
			_indent = null;
			_mangleNames = false;
			_dataContext = null;
			_exprBuilder = default!;
			_typeBuilder = default!;
			_usedTypes = null;
			_usedMembers = default!;
			_nameDic = default!;
			_typeNames = default!;
			_visitedExprs = default!;

			base.Cleanup();
		}

		public static string GenerateSourceString(IDataContext dataContext, Expression expr, bool mangleNames = true)
		{
			using var generator = Pool.Allocate();

			return generator.Value.GenerateSource(dataContext, expr, mangleNames);
		}

		public static string? GenerateSourceFile(IDataContext dataContext, Expression expr, bool mangleNames = true)
		{
			var fileName = GetTestFilePath();
			StreamWriter? sw = null;

			try
			{
				sw = File.CreateText(fileName);

				var source = GenerateSourceString(dataContext, expr, mangleNames);
				sw.WriteLine(source);
			}
			catch (Exception ex)
			{
				if (sw != null)
				{
					sw.WriteLine();
					sw.WriteLine(ex.GetType());
					sw.WriteLine(ex.Message);
					sw.WriteLine(ex.StackTrace);
				}
				else
				{
					throw;
				}
			}
			finally
			{
				sw?.Dispose();
			}

			return fileName;
		}

		string GenerateSource(IDataContext dataContext, Expression expr, bool mangleNames)
		{
			_indent = "\t\t\t\t";
			_mangleNames = mangleNames;
			_dataContext = dataContext;
			_usedTypes = new();
			_usedMembers = new();
			_nameDic = new();
			_visitedExprs = new();

			_typeNames = new()
			{
				{ typeof(object), "object" },
				{ typeof(bool),   "bool"   },
				{ typeof(int),    "int"    },
				{ typeof(string), "string" },
			};

			using var sb1 = Pools.StringBuilder.Allocate();
			using var sb2 = Pools.StringBuilder.Allocate();

			_exprBuilder = sb1.Value;
			_typeBuilder = sb2.Value;

			expr.Visit(VisitMembers);
			expr.Visit(VisitTypes);

			foreach (var typeNamespaceList in _usedTypes.OrderBy(t => t.Namespace).GroupBy(x => x.Namespace))
			{
				if (typeNamespaceList.All(type =>
				{
					return (!IsUserType(type) ||
							IsAnonymous(type) ||
							type.Assembly == GetType().Assembly ||
							type.IsGenericType && type.GetGenericTypeDefinition() != type);
				}))
					continue;
				_typeBuilder.AppendLine("namespace " + MangleName(IsUserNamespace(typeNamespaceList.Key), typeNamespaceList.Key, "T"));
				_typeBuilder.AppendLine("{");
				foreach (var type in typeNamespaceList.OrderBy(t => t.Name))
				{
					BuildType(type, _dataContext.MappingSchema, _dataContext.Options);
				}

				_typeBuilder.AppendLine("}");
			}

			Visit(expr);

			_exprBuilder.Replace("<>h__TransparentIdentifier", "tp");
			_exprBuilder.Insert(0, "var query = ");

			return string.Format(
				CultureInfo.InvariantCulture,
				TEMPLATE,
				_typeBuilder,
				_nameDic.Aggregate(expr.ToString(), (current, item) => current.Replace(item.Key.Length == 1 ? item.Key : item.Key.Substring(1), item.Value)),
				_exprBuilder);
		}

		void PushIndent() { _indent += '\t'; }
		void PopIndent() { _indent = _indent!.Substring(1); }

		protected override Expression VisitBinary(BinaryExpression node)
		{
			if (node.NodeType == ExpressionType.ArrayIndex)
			{
				Visit(node.Left);
				_exprBuilder.Append('[');
				Visit(node.Right);
				_exprBuilder.Append(']');

				return node;
			}

			var op = node.NodeType switch
			{
				ExpressionType.Add or ExpressionType.AddChecked => " + ",
				ExpressionType.And               => " & ",
				ExpressionType.AndAlso           => " && ",
				ExpressionType.Assign            => " = ",
				ExpressionType.Coalesce          => " ?? ",
				ExpressionType.Divide            => " / ",
				ExpressionType.Equal             => " == ",
				ExpressionType.ExclusiveOr       => " ^ ",
				ExpressionType.GreaterThan       => " > ",
				ExpressionType.GreaterThanOrEqual=> " >= ",
				ExpressionType.LeftShift         => " << ",
				ExpressionType.LessThan          => " < ",
				ExpressionType.LessThanOrEqual   => " <= ",
				ExpressionType.Modulo            => " % ",
				ExpressionType.Multiply or ExpressionType.MultiplyChecked   => " * ",
				ExpressionType.NotEqual          => " != ",
				ExpressionType.Or                => " | ",
				ExpressionType.OrElse            => " || ",
				ExpressionType.Power             => " ** ",
				ExpressionType.RightShift        => " >> ",
				ExpressionType.Subtract or ExpressionType.SubtractChecked  => " - ",
				_ => null
			};

			if (op != null)
			{
				_exprBuilder.Append('(');
				Visit(node.Left);
				_exprBuilder.Append(op);
				Visit(node.Right);
				_exprBuilder.Append(')');
			}

			return node;
		}

		protected override Expression VisitUnary(UnaryExpression node)
		{
			switch (node.NodeType)
			{
				case ExpressionType.ArrayLength:
				{
					Visit(node.Operand);
					_exprBuilder.Append(".Length");

					break;
				}

				case ExpressionType.Convert:
				case ExpressionType.ConvertChecked:
				{
					_exprBuilder.Append(CultureInfo.InvariantCulture, $"({GetTypeName(node.Type)})");
					Visit(node.Operand);

					break;
				}

				case ExpressionType.TypeAs:
				{
					_exprBuilder.Append('(');
					Visit(node.Operand);
					_exprBuilder.Append(CultureInfo.InvariantCulture, $" as {GetTypeName(node.Type)})");

					break;
				}

				case ExpressionType.Negate:
				case ExpressionType.NegateChecked:
				{
					_exprBuilder.Append('-');
					Visit(node.Operand);
					break;
				}

				case ExpressionType.Not:
				{
					_exprBuilder.Append('!');
					Visit(node.Operand);
					break;
				}

				case ExpressionType.UnaryPlus:
				{
					_exprBuilder.Append('+');
					Visit(node.Operand);
					break;
				}
			}

			return node;
		}

		protected override Expression VisitMember(MemberExpression node)
		{
			Visit(node.Expression!);

			_exprBuilder.Append(CultureInfo.InvariantCulture, $".{MangleName(node.Member.DeclaringType!, node.Member.Name, "P")}");

			return node;
		}

		protected override Expression VisitParameter(ParameterExpression node)
		{
			_exprBuilder.Append(MangleName(node.Name, "p"));

			return node;
		}

		protected override Expression VisitMethodCall(MethodCallExpression node)
		{
			var mi = node.Method;

			var isExtension = mi.HasAttribute<ExtensionAttribute>(false);

			if (isExtension)
			{
				Visit(node.Arguments[0]);
				PushIndent();
				_exprBuilder.AppendLine().Append(_indent);
			}
			else if (node.Object != null)
				Visit(node.Object);
			else
				_exprBuilder.Append(GetTypeName(mi.DeclaringType!));

			_exprBuilder.Append('.').Append(MangleName(mi.DeclaringType!, mi.Name, "M"));

			if ((!node.IsQueryable() || node.Method.DeclaringType == typeof(DataExtensions))
				&& mi.IsGenericMethod && mi.GetGenericArguments().Select(GetTypeName).All(t => t != null))
			{
				_exprBuilder
					.Append('<')
					.Append(GetTypeNames(mi.GetGenericArguments(), ","))
					.Append('>');
			}

			_exprBuilder.Append('(');

			PushIndent();

			var n = isExtension ? 1 : 0;

			for (var i = n; i < node.Arguments.Count; i++)
			{
				if (i != n)
					_exprBuilder.Append(',');

				_exprBuilder.AppendLine().Append(_indent);

				Visit(node.Arguments[i]);
			}

			PopIndent();

			_exprBuilder.Append(')');

			if (isExtension)
			{
				PopIndent();
			}

			return node;
		}

		protected override Expression VisitConstant(ConstantExpression node)
		{
			if (node.Value is IQueryable queryable)
			{
				var e = queryable.Expression;

				if (_visitedExprs.Add(e))
				{
					Visit(e);
					return node;
				}
			}

			if (typeof(Table<>).IsSameOrParentOf(node.Type))
				_exprBuilder.Append(CultureInfo.InvariantCulture, $"db.GetTable<{GetTypeName(node.Type.GetGenericArguments()[0])}>()");
			else if (node.Value == _dataContext || node.Value == null && typeof(IDataContext).IsSameOrParentOf(node.Type))
				_exprBuilder.Append("db");
			else if (node.ToString() == "value(" + node.Type + ")")
				_exprBuilder.Append("value(").Append(GetTypeName(node.Type)).Append(')');
			else
				_exprBuilder.Append(CultureInfo.InvariantCulture, $"{node}");

			return node;
		}

		protected override Expression VisitLambda<T>(Expression<T> node)
		{
			var ps = string.Join(", ", node.Parameters.Select(p => MangleName(p.Name, "p")));

			if (node.Parameters.Count == 1)
				_exprBuilder.Append(ps);
			else
				_exprBuilder.Append('(').Append(ps).Append(')');
			_exprBuilder.Append(" => ");

			Visit(node.Body);

			return node;
		}

		protected override Expression VisitConditional(ConditionalExpression node)
		{
			_exprBuilder.Append('(');
			Visit(node.Test);
			_exprBuilder.Append(" ? ");
			Visit(node.IfTrue);
			_exprBuilder.Append(" : ");
			Visit(node.IfFalse);
			_exprBuilder.Append(')');

			return node;
		}

		protected override Expression VisitNew(NewExpression node)
		{
			if (IsAnonymous(node.Type))
			{
				if (node.Members!.Count == 1)
				{
					_exprBuilder.Append(CultureInfo.InvariantCulture, $"new {{ {MangleName(node.Members[0].DeclaringType!, node.Members[0].Name, "P")} = ");
					Visit(node.Arguments[0]);
					_exprBuilder.Append(" }}");
				}
				else
				{
					_exprBuilder.AppendLine("new").Append(_indent).Append('{');

					PushIndent();

					for (var i = 0; i < node.Members.Count; i++)
					{
						_exprBuilder
							.AppendLine()
							.Append(CultureInfo.InvariantCulture, $"{_indent}{MangleName(node.Members[i].DeclaringType!, node.Members[i].Name, "P")} = ");
						Visit(node.Arguments[i]);

						if (i + 1 < node.Members.Count)
							_exprBuilder.Append(',');
					}

					PopIndent();
					_exprBuilder.AppendLine().Append(_indent).Append('}');
				}
			}
			else
			{
				_exprBuilder.Append(CultureInfo.InvariantCulture, $"new {GetTypeName(node.Type)}(");

				for (var i = 0; i < node.Arguments.Count; i++)
				{
					Visit(node.Arguments[i]);
					if (i + 1 < node.Arguments.Count)
						_exprBuilder.Append(", ");
				}

				_exprBuilder.Append(')');
			}

			return node;
		}

		protected override Expression VisitMemberInit(MemberInitExpression node)
		{
			Visit(node.NewExpression);

			if (node.Bindings.Count == 1)
			{
				_exprBuilder.Append(" { ");
				Modify(node.Bindings[0]);
				_exprBuilder.Append(" }");
			}
			else
			{
				_exprBuilder.AppendLine().Append(_indent).Append('{');

				PushIndent();

				for (var i = 0; i < node.Bindings.Count; i++)
				{
					_exprBuilder.AppendLine().Append(_indent);
					Modify(node.Bindings[i]);
					if (i + 1 < node.Bindings.Count)
						_exprBuilder.Append(',');
				}

				PopIndent();
				_exprBuilder.AppendLine().Append(_indent).Append('}');
			}

			return node;

			void Modify(MemberBinding b)
			{
				switch (b.BindingType)
				{
					case MemberBindingType.Assignment:
						var ma = (MemberAssignment) b;
						_exprBuilder.Append(CultureInfo.InvariantCulture, $"{MangleName(ma.Member.DeclaringType!, ma.Member.Name, "P")} = ");
						Visit(ma.Expression);
						break;
					default:
						_exprBuilder.Append(CultureInfo.InvariantCulture, $"{b}");
						break;
				}
			}
		}

		protected override Expression VisitNewArray(NewArrayExpression node)
		{
			_exprBuilder.Append(CultureInfo.InvariantCulture, $"new {GetTypeName(node.Type.GetElementType()!)}[]");

			if (node.Expressions.Count == 1)
			{
				_exprBuilder.Append(" { ");
				Visit(node.Expressions[0]);
				_exprBuilder.Append(" }");
			}
			else
			{
				_exprBuilder.AppendLine().Append(_indent).Append('{');

				PushIndent();

				for (var i = 0; i < node.Expressions.Count; i++)
				{
					_exprBuilder.AppendLine().Append(_indent);
					Visit(node.Expressions[i]);
					if (i + 1 < node.Expressions.Count)
						_exprBuilder.Append(',');
				}

				PopIndent();
				_exprBuilder.AppendLine().Append(_indent).Append('}');
			}

			return node;
		}

		protected override Expression VisitTypeBinary(TypeBinaryExpression node)
		{
			_exprBuilder.Append('(');
			Visit(node.Expression);
			_exprBuilder.Append(CultureInfo.InvariantCulture, $" is {node.TypeOperand})");

			return node;
		}

		protected override Expression VisitListInit(ListInitExpression node)
		{
			Visit(node.NewExpression);

			if (node.Initializers.Count == 1)
			{
				_exprBuilder.Append(" { ");
				Visit(node.Initializers[0].Arguments[0]);
				_exprBuilder.Append(" }");
			}
			else
			{
				_exprBuilder.AppendLine().Append(_indent).Append('{');

				PushIndent();

				for (var i = 0; i < node.Initializers.Count; i++)
				{
					_exprBuilder.AppendLine().Append(_indent);
					Visit(node.Initializers[i].Arguments[0]);
					if (i + 1 < node.Initializers.Count)
						_exprBuilder.Append(',');
				}

				PopIndent();
				_exprBuilder.AppendLine().Append(_indent).Append('}');
			}

			return node;
		}

		protected override Expression VisitInvocation(InvocationExpression node)
		{
			_exprBuilder.Append("Expression.Invoke(");
			Visit(node.Expression);
			_exprBuilder.Append(", (");

			for (var i = 0; i < node.Arguments.Count; i++)
			{
				Visit(node.Arguments[i]);
				if (i + 1 < node.Arguments.Count)
					_exprBuilder.Append(", ");
			}

			_exprBuilder.Append("))");

			return node;
		}

		void BuildType(Type type, MappingSchema mappingSchema, DataOptions dataOptions)
		{
			if (!IsUserType(type) ||
				IsAnonymous(type) ||
				type.Assembly == GetType().Assembly ||
				type.IsGenericType && type.GetGenericTypeDefinition() != type)
				return;

			var isUserName = IsUserType(type);
			var name       = MangleName(isUserName, type.Name, "T");
			var idx        = name.LastIndexOf('`');

			if (idx > 0)
				name = name.Substring(0, idx);

			if (type.IsGenericType)
				type = type.GetGenericTypeDefinition();

			if (type.IsEnum)
			{
				var enumMappings = mappingSchema.GetMapValues(type)!;
				_typeBuilder.AppendLine("\tenum " + MangleName(isUserName, type.Name, "T") + " {");

				foreach (var mappings in enumMappings)
				{
					foreach (var valueAttribute in mappings.MapValues)
					{
						// TODO: this is not correct, we should generate literal of proper type instead of always string
						_typeBuilder.AppendLine(CultureInfo.InvariantCulture, $"\t\t[MapValue(\"{valueAttribute.Value}\")]");
					}

					// TODO: will not work for UInt64-based enums, and in general we should generate base type
					_typeBuilder.AppendLine(CultureInfo.InvariantCulture, $"\t\t{mappings.OrigValue} = {Convert.ToInt64(mappings.OrigValue, CultureInfo.InvariantCulture)},");
				}

				_typeBuilder.Remove(_typeBuilder.Length - 1, 1);
				_typeBuilder.AppendLine("\t}");
				return;
			}

			var baseClasses = CollectBaseTypes(type);

			var ctors = type.GetConstructors().Select(c =>
			{
				var attrs = c.GetCustomAttributesData();
				var attr  = string.Concat(attrs.Select(a => "\r\n\t\t" + a.ToString()));
				var ps    = c.GetParameters().Select(p => GetTypeName(p.ParameterType) + " " + MangleName(p.Name, "p"));

				return string.Format(CultureInfo.InvariantCulture, @"{0}
		public {1}({2})
		{{
			// throw new NotImplementedException();
		}}",
					attr,
					name,
					string.Join(", ", ps));
			}).ToList();

			if (ctors.Count == 1 && ctors[0].IndexOf("()", StringComparison.Ordinal) >= 0)
				ctors.Clear();

			var members = type.GetFields().Intersect(_usedMembers.OfType<FieldInfo>()).Select(f =>
			{
				var attr = "";
				var ed = mappingSchema.GetEntityDescriptor(type, dataOptions.ConnectionOptions.OnEntityDescriptorCreated);
				if (ed != null)
				{
					var colum = ed.Columns.FirstOrDefault(x => x.MemberInfo == f);
					if (colum != null)
					{
						attr += "\t\t[Column(" + (string.IsNullOrEmpty(colum.ColumnName) ? "" : "\"" + colum.ColumnName + "\"") + ")]" + Environment.NewLine;
					}
					else
					{
						attr += "\t\t[NotColumn]" + Environment.NewLine;
					}

					if (colum != null && colum.IsPrimaryKey)
					{
						attr += "\t\t[PrimaryKey]" + Environment.NewLine;
					}
				}

				return string.Format(CultureInfo.InvariantCulture, @"
{0}		public {1} {2};",
					attr,
					GetTypeName(f.FieldType),
					MangleName(isUserName, f.Name, "P"));
			})
			.Concat(
				type.GetPropertiesEx().Intersect(_usedMembers.OfType<PropertyInfo>()).Select(p =>
				{
					var attr = "";
					var ed = mappingSchema.GetEntityDescriptor(type, dataOptions.ConnectionOptions.OnEntityDescriptorCreated);
					if (ed != null)
					{
						var colum = ed.Columns.FirstOrDefault(x => x.MemberInfo == p);
						if (colum != null)
						{
							attr += "\t\t[Column(" + (string.IsNullOrEmpty(colum.ColumnName) ? "" : "\"" + colum.ColumnName + "\"") + ")]" + Environment.NewLine;
						}
						else
						{
							attr += "\t\t[NotColumn]" + Environment.NewLine;
						}

						if (colum != null && colum.IsPrimaryKey)
						{
							attr += "\t\t[PrimaryKey]" + Environment.NewLine;
						}
					}

					return string.Format(CultureInfo.InvariantCulture, @"
{0}		{3}{1} {2} {{ get; set; }}",
						attr,
						GetTypeName(p.PropertyType),
						MangleName(isUserName, p.Name, "P"),
						type.IsInterface ? "" : "public ");
				}))
			.Concat(
				type.GetMethods().Intersect(_usedMembers.OfType<MethodInfo>()).Select(m =>
				{
					var attrs = m.GetCustomAttributesData();
					var ps    = m.GetParameters().Select(p => GetTypeName(p.ParameterType) + " " + MangleName(p.Name, "p"));
					return string.Format(CultureInfo.InvariantCulture, @"{0}
		{5}{4}{1} {2}({3})
		{{
			throw new NotImplementedException();
		}}",
						string.Concat(attrs.Select(a => "\r\n\t\t" + a.ToString())),
						GetTypeName(m.ReturnType),
						MangleName(isUserName, m.Name, "M"),
						string.Join(", ", ps),
						m.IsStatic   ? "static "   :
						m.IsVirtual  ? "virtual "  :
						m.IsAbstract ? "abstract " :
						               "",
						type.IsInterface ? "" : "public ");
				}))
			.ToArray();

			{
				var attr = "";
				var ed = mappingSchema.GetEntityDescriptor(type, dataOptions.ConnectionOptions.OnEntityDescriptorCreated);
				if (ed != null && !type.IsInterface)
				{
					attr += "\t[Table(" + (string.IsNullOrEmpty(ed.Name.Name) ? "" : "\"" + ed.Name.Name + "\"") + ")]" + Environment.NewLine;
				}

				_typeBuilder.AppendFormat(
					CultureInfo.InvariantCulture,
					type.IsGenericType ?
@"
{0}	{1}{2}{3} {4}<{8}>{5}
	{{{6}{7}
	}}
"
:
@"
{0}	{1}{2}{3} {4}{5}
	{{{6}{7}
	}}
",
					attr,
					type.IsPublic ? "public " : string.Empty,
					type.IsAbstract && !type.IsInterface ? "abstract " : string.Empty,
					type.IsInterface ? "interface" : type.IsClass ? "class" : "struct",
					name,
					baseClasses.Length == 0 ? string.Empty : " : " + GetTypeNames(baseClasses),
					string.Join("\r\n", ctors),
					members.Length > 0 ? (ctors.Count != 0 ? "\r\n" : string.Empty) + string.Join("\r\n", members) : string.Empty,
					type.IsGenericType ? GetTypeNames(type.GetGenericArguments(), ",") : string.Empty);
			}
		}

		static Type[] CollectBaseTypes(Type type)
		{
			var types = new List<Type>();
			var duplicateInterfaces = new HashSet<Type>();

			if (type.BaseType != null && type.BaseType != typeof(object))
			{
				types.Add(type.BaseType);

				populateBaseInterfaces(type.BaseType, duplicateInterfaces);
			}

			foreach (var iface in type.GetInterfaces())
				if (duplicateInterfaces.Add(iface))
				{
					types.Add(iface);
					populateBaseInterfaces(iface, duplicateInterfaces);
				}

			return types.ToArray();

			static void populateBaseInterfaces(Type type, HashSet<Type> duplicateInterfaces)
			{
				foreach (var iface in type.GetInterfaces())
					duplicateInterfaces.Add(iface);
			}
		}

		string GetTypeNames(IEnumerable<Type> types, string separator = ", ")
		{
			return string.Join(separator, types.Select(GetTypeName));
		}

		static bool IsAnonymous(Type type)
		{
			return type.Name.StartsWith("<>");
		}

		string MangleName(Type type, string? name, string prefix)
		{
			return IsUserType(type) ? MangleName(name, prefix) : name ?? prefix;
		}

		string MangleName(bool isUserType, string? name, string prefix)
		{
			return isUserType ? MangleName(name, prefix) : name ?? prefix;
		}

		string MangleName(string? name, string prefix)
		{
			name ??= "";
			if (!_mangleNames)
				return name;

			var oldNames = name.Split('.');
			var newNames = new string[oldNames.Length];

			for (var i = 0; i < oldNames.Length; i++)
			{
				if (_nameDic.TryGetValue(prefix + oldNames[i], out var mangledName))
					newNames[i] = mangledName;
				else
					newNames[i] = _nameDic[prefix + oldNames[i]] = FormattableString.Invariant($"{prefix}{_nameDic.Count}");
			}

			return string.Join(".", newNames);
		}

		bool IsUserType(Type type)
		{
			return IsUserNamespace(type.Namespace);
		}

		static bool IsUserNamespace(string? @namespace)
		{
			return @namespace == null || SystemNamespaces.All(ns => @namespace != ns && !@namespace.StartsWith(ns + '.'));
		}

		string? GetTypeName(Type type)
		{
			if (type == null || type == typeof(object))
				return null;

			if (type.IsGenericParameter)
				return type.ToString();

			if (_typeNames.TryGetValue(type, out var name))
				return name;

			if (IsAnonymous(type))
			{
				_typeNames[type] = null;
				return null;
			}

			if (type.IsGenericType)
			{
				var args = type.GetGenericArguments();

				name = "";

				if (type.Namespace != "System")
					name = type.Namespace + ".";

				name += type.Name;

				var idx = name.LastIndexOf('`');

				if (idx > 0)
					name = name.Substring(0, idx);

				if (type.IsNullableType)
				{
					name = $"{GetTypeName(args[0])}?";
				}
				else
				{
					name = string.Format(
						CultureInfo.InvariantCulture,
						"{0}<{1}>",
						name,
						string.Join(", ", args.Select(GetTypeName)));
				}

				_typeNames[type] = name;

				return name;
			}

			if (type.Namespace == "System")
				return type.Name;

			return MangleName(type, type.ToString(), "T");
		}

		void VisitMembers(Expression expr)
		{
			switch (expr.NodeType)
			{
				case ExpressionType.Call :
					{
						var ex = (MethodCallExpression)expr;
						_usedMembers.Add(ex.Method);

						if (ex.Method.IsGenericMethod)
						{
							var gmd = ex.Method.GetGenericMethodDefinition();

							if (gmd != ex.Method)
								_usedMembers.Add(gmd);

							var ga = ex.Method.GetGenericArguments();

							foreach (var type in ga)
								_usedMembers.Add(type);
						}

						break;
					}

				case ExpressionType.MemberAccess :
					{
						var ex = (MemberExpression)expr;
						_usedMembers.Add(ex.Member);
						break;
					}

				case ExpressionType.MemberInit :
					{
						var ex = (MemberInitExpression)expr;

						void Visit(IEnumerable<MemberBinding> bs)
						{
							foreach (var b in bs)
							{
								_usedMembers.Add(b.Member);

								switch (b.BindingType)
								{
									case MemberBindingType.MemberBinding:
										Visit(((MemberMemberBinding) b).Bindings);
										break;
								}
							}
						}

						Visit(ex.Bindings);
						break;
					}
			}
		}

		void AddType(Type? type)
		{
			if (type == null || type == typeof(object) || type.IsGenericParameter || _usedTypes!.Contains(type))
				return;

			_usedTypes.Add(type);

			if (type.IsGenericType)
				foreach (var arg in type.GetGenericArguments())
					AddType(arg);

			if (type.IsGenericType && type.GetGenericTypeDefinition() != type)
				AddType(type.GetGenericTypeDefinition());

			AddType(type.BaseType);

			foreach (var i in type.GetInterfaces())
				AddType(i);
		}

		void VisitTypes(Expression expr)
		{
			AddType(expr.Type);

			switch (expr.NodeType)
			{
				case ExpressionType.Call :
					{
						var ex = (MethodCallExpression)expr;
						var mi = ex.Method;

						AddType(mi.DeclaringType);
						AddType(mi.ReturnType);

						foreach (var arg in mi.GetGenericArguments())
							AddType(arg);

						break;
					}
			}
		}

		static string GetTestFilePath()
		{
			var dir = Path.Combine(Path.GetTempPath(), "linq2db");

			if (!Directory.Exists(dir))
				Directory.CreateDirectory(dir);

			return Path.Combine(dir, FormattableString.Invariant($"ExpressionTest.0.cs"));
		}
	}
}
