<#@ assembly name="System.Core"                   #>
<#@ import namespace="System"                     #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq"                #>
<#@ import namespace="System.Text"                #>
<#+
static Action<GeneratedTextTransformation,string> WriteComment    = (tt,s) => tt.WriteLine("//{0}", s);

Action BeforeGenerateModel = () => {};

bool GenerateProcedureErrors             = true;

static bool EnableNullableReferenceTypes = false;
static Func<string, bool> IsValueType    = IsValueTypeDefault;

void GenerateModel()
{
	Model.SetTree();

	if (GenerationEnvironment.Length > 0 && GenerationEnvironment.ToString().Trim().Length == 0)
		GenerationEnvironment.Length = 0;

	WriteComment(this, "---------------------------------------------------------------------------------------------------");
	WriteComment(this, " <auto-generated>");
	WriteComment(this, "    This code was generated by T4Model template for T4 (https://github.com/linq2db/linq2db).");
	WriteComment(this, "    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteComment(this, " </auto-generated>");
	WriteComment(this, "---------------------------------------------------------------------------------------------------");

	WriteLine("");
	WriteLine("#pragma warning disable 1591");
	if (EnableNullableReferenceTypes)
		WriteLine($"#nullable enable");
	WriteLine("");

	BeforeGenerateModel();

	Model.Render(this);

	WriteLine("");
	WriteLine("#pragma warning restore 1591");
}

void Trim()
{
	var arr = new[] { '\r', '\n', ' ' };
	while (GenerationEnvironment.Length > 0 && arr.Contains(GenerationEnvironment[GenerationEnvironment.Length - 1]))
		GenerationEnvironment.Length--;

	WriteLine("");
}

static Action<GeneratedTextTransformation,string> WriteUsing = (tt,s) => tt.WriteLine("using {0};", s);

void RenderUsings(List<string> usings)
{
	var q =
		from ns in usings.Distinct()
		group ns by ns.Split('.')[0];

	var groups =
		(from ns in q where ns.Key == "System"                select ns).Concat
		(from ns in q where ns.Key != "System" orderby ns.Key select ns);

	foreach (var gr in groups)
	{
		foreach (var ns in from s in gr orderby s select s)
			WriteUsing(this, ns);

		WriteLine("");
	}

	Trim();
}

// Base data types.
//
public interface ITree
{
	ITree              Parent { get; set; }
	IEnumerable<ITree> GetNodes();
	void               SetTree();
}

ModelSource Model = new ModelSource();

public partial class ModelSource : ITree
{
	public int CurrentNamespace = 0;

	public List<string>    Usings     = new List<string>    { "System"        };
	public List<Namespace> Namespaces = new List<Namespace> { new Namespace() };

	public Namespace      Namespace { get { return Namespaces[CurrentNamespace];       } }
	public List<TypeBase> Types     { get { return Namespaces[CurrentNamespace].Types; } }

	public virtual void Render(GeneratedTextTransformation tt)
	{
		tt.RenderUsings(Usings);
		tt.WriteLine("");

		foreach (var nm in Namespaces)
		{
			nm.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();
	}

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Namespaces; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<GeneratedTextTransformation,string> WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
static Action<GeneratedTextTransformation>        WriteEndNamespace   =  tt    => tt.WriteLine("}");

public partial class Namespace : ITree
{
	public string         Name;
	public List<TypeBase> Types  = new List<TypeBase>();
	public List<string>   Usings = new List<string>();

	public virtual void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Name))
		{
			WriteBeginNamespace(tt, Name);
			tt.PushIndent("\t");
		}

		tt.RenderUsings(Usings);

		foreach (var t in Types)
		{
			t.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Name))
		{
			tt.PopIndent();
			WriteEndNamespace(tt);
		}
	}

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Types; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public interface IClassMember : ITree
{
}

public enum AccessModifier
{
	Public,
	Protected,
	Internal,
	Private,
	Partial,
	None
}

public abstract partial class TypeBase : IClassMember
{
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public bool            IsPartial  = true;
	public List<string>    Comment    = new List<string>();
	public List<Attribute> Attributes = new List<Attribute>();
	public string          Conditional;
	public string          ClassKeyword = "class";

	public abstract void Render(GeneratedTextTransformation tt);

	protected virtual void BeginConditional(GeneratedTextTransformation tt)
	{
		if (Conditional != null)
		{
			tt.RemoveSpace();
			tt.WriteLine("#if " + Conditional);
			tt.WriteLine("");
		}
	}

	protected virtual void EndConditional(GeneratedTextTransformation tt)
	{
		if (Conditional != null)
		{
			tt.RemoveSpace();
			tt.WriteLine("");
			tt.RemoveSpace();
			tt.WriteLine("#endif");
		}
	}

	public          ITree              Parent { get; set; }
	public abstract IEnumerable<ITree> GetNodes();
	public abstract void               SetTree ();
}

static Action<GeneratedTextTransformation,Class> WriteBeginClass = (tt,cl) =>
{
	tt.Write(cl.AccessModifier.ToString().ToLower() + " ");
	if (cl.IsStatic)  tt.Write("static ");
	if (cl.IsPartial) tt.Write("partial ", cl.Name);
	tt.Write("{0} {1}{2}", cl.ClassKeyword, cl.Name, cl.GenericArguments.Count > 0 ? $"<{string.Join(", ", cl.GenericArguments)}>" : string.Empty);

	if (!string.IsNullOrEmpty(cl.BaseClass) || cl.Interfaces.Count > 0)
	{
		var arr = new[] { cl.BaseClass }.Concat(cl.Interfaces)
			.Where(n => n != null)
			.ToArray();

		tt.Write(" : ");
		tt.Write(string.Join(", ", arr));
	}

	tt.WriteLine("");
	tt.WriteLine("{");
};

static Action<GeneratedTextTransformation> WriteEndClass = tt => tt.WriteLine("}");

public partial class Class : TypeBase
{
	public string             BaseClass;
	public List<string>       GenericArguments   = new List<string>();
	public bool               IsStatic           = false;
	public List<string>       Interfaces         = new List<string>();
	public List<IClassMember> Members            = new List<IClassMember>();

	public Class()
	{
	}

	public Class(string name, params IClassMember[] members)
	{
		Name = name;
		Members.AddRange(members);
	}

	public override void Render(GeneratedTextTransformation tt)
	{
		BeginConditional(tt);

		foreach (var c in Comment)
			tt.WriteLine("//" + c);

		if (Attributes.Count > 0)
		{
			var aa = Attributes.Where(a => !a.IsSeparated).ToList();

			if (aa.Count > 0)
			{
				tt.Write("[");

				for (var i = 0; i < aa.Count; i++)
				{
					if (i > 0) SkipSpacesAndInsert(tt, ", ");
					aa[i].Render(tt);
				}

				tt.WriteLine("]");
			}

			aa = Attributes.Where(a => a.IsSeparated).ToList();

			foreach (var a in aa)
			{
				tt.Write("[");
				a.Render(tt);
				tt.WriteLine("]");
			}
		}

		WriteBeginClass(tt, this);
		tt.PushIndent("\t");

		foreach (var cm in Members)
		{
			if (cm is MemberBase)
			{
				var m = (MemberBase)cm;

				if (!(m is MemberGroup))
					m.BeginConditional(tt, false);

				foreach (var c in m.Comment)
					WriteComment(tt, c);

				if (m.Attributes.Count > 0)
				{
					var q =
						from a in m.Attributes
						group a by a.Conditional ?? "";

					foreach (var g in q)
					{
						if (g.Key.Length > 0)
						{
							tt.RemoveSpace();
							tt.WriteLine("#if " + g.Key);
						}

						var attrs = g.ToList();

						tt.Write("[");

						for (var i = 0; i < attrs.Count; i++)
						{
							if (i > 0) SkipSpacesAndInsert(tt, ", ");
							attrs[i].Render(tt);
						}

						tt.WriteLine("]");

						if (g.Key.Length > 0)
						{
							tt.RemoveSpace();
							tt.WriteLine("#endif");
						}
					}
				}

				m.Render(tt, false);
				if (m.InsertBlankLineAfter)
					tt.WriteLine("");

				if (!(m is MemberGroup))
					m.EndConditional(tt, false);
			}
			else if (cm is TypeBase)
			{
				var t = (TypeBase)cm;

				t.Render(tt);
				tt.WriteLine("");
			}
		}

		tt.Trim();

		tt.PopIndent();
		WriteEndClass(tt);

		EndConditional(tt);
	}

	public override IEnumerable<ITree> GetNodes()
	{
		return Members;
	}

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public abstract partial class MemberBase : IClassMember
{
	public string          ID;
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public Func<string>    TypeBuilder;
	public List<string>    Comment = new List<string>();
	public string          EndLineComment;
	public List<Attribute> Attributes = new List<Attribute>();
	public bool            InsertBlankLineAfter = true;
	public string          Conditional;

	public int AccessModifierLen;
	public int ModifierLen;
	public int TypeLen;
	public int NameLen;
	public int ParamLen;
	public int BodyLen;

	public string Type
	{
		get { return TypeBuilder?.Invoke(); }
		set { TypeBuilder = () => value;    }
	}

	public string BuildType() { return TypeBuilder?.Invoke(); }

	public virtual  int  CalcModifierLen() { return 0; }
	public abstract int  CalcBodyLen    ();
	public virtual  int  CalcParamLen   () { return 0; }
	public abstract void Render         (GeneratedTextTransformation tt, bool isCompact);

	public virtual void BeginConditional(GeneratedTextTransformation tt, bool isCompact)
	{
		if (Conditional != null)
		{
			tt.RemoveSpace();
			tt.WriteLine("#if " + Conditional);
			if (!isCompact)
				tt.WriteLine("");
		}
	}

	public virtual void EndConditional(GeneratedTextTransformation tt, bool isCompact)
	{
		if (Conditional != null)
		{
			tt.RemoveSpace();
			tt.WriteLine("#endif");
			if (!isCompact)
				tt.WriteLine("");
		}
	}

	public         ITree              Parent     { get; set; }
	public virtual IEnumerable<ITree> GetNodes() { return Enumerable.Empty<ITree>(); }
	public virtual void               SetTree () {}
}

static Action<GeneratedTextTransformation,string> BeginRegion = (tt,s) => { tt.WriteLine("#region {0}", s); };
static Action<GeneratedTextTransformation>        EndRegion   = (tt)   => { tt.WriteLine("#endregion");     };

public partial class MemberGroup : MemberBase
{
	public string             Region;
	public bool               IsCompact;
	public bool               IsPropertyGroup;
	public List<IClassMember> Members = new List<IClassMember>();
	public List<string>       Errors  = new List<string>();

	public override int  CalcBodyLen() { return 0; }

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		if (!string.IsNullOrEmpty(Region))
		{
			BeginRegion(tt, Region);
			tt.WriteLine("");
		}

		BeginConditional(tt, isCompact);

		if (Errors.Count > 0 && tt.GenerateProcedureErrors)
		{
			tt.RemoveSpace();
			WriteComment(tt, " Use 'GenerateProcedureErrors=false' to disable errors.");
			foreach (var error in Errors)
			{
				tt.Error(error);

				foreach (var e in error.Split('\n'))
				{
					tt.RemoveSpace();
					tt.WriteLine("#error " + e.Trim('\r'));
				}
			}

			tt.WriteLine("");
		}

		if (IsCompact)
		{
			var allMembers = GetTreeNodes(this).OfType<MemberBase>().Where(m => !(m is MemberGroup)).ToList();

			if (allMembers.Count > 0)
			{
				int max = allMembers.Max(m => m.AccessModifier == AccessModifier.None ? 0 : m.AccessModifier.ToString().Length);
				foreach (var m in allMembers)
					m.AccessModifierLen = max;

				max = allMembers.Max(m => m.CalcModifierLen());
				foreach (var m in allMembers)
					m.ModifierLen = max;

				max = allMembers.Max(m => (m.BuildType() ?? "").Length);
				foreach (var m in allMembers)
					m.TypeLen = max;

				var notHasGetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasGetter);
				var notHasSetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasSetter);

				foreach (var p in allMembers.OfType<Property>())
				{
					if (notHasGetter) p.GetterLen = 13;
					if (notHasSetter) p.SetterLen = 13;
				}

				max = allMembers.Max(m => m.Name.Length);
				foreach (var m in allMembers)
					m.NameLen = max;

				max = allMembers.Max(m => m.CalcParamLen());
				foreach (var m in allMembers)
					m.ParamLen = max;

				max = allMembers.Max(m => m.CalcBodyLen());
				foreach (var m in allMembers)
					m.BodyLen = max;

				var members =
				(
					from m in allMembers
					select new
					{
						m,
						attrs =
						(
							from a in m.Attributes
							group a by a.Name into gr
							select gr.Select((a,i) => new { a, name = a.Name + "." + i }).ToList() into s
							from a in s
							select a
						).ToList()
					}
				).ToList();

				var attrWeight =
				(
					from m in members
					from a in m.attrs
					group a by a.name into gr
					select new { gr.Key, Count = gr.Count() }
				).ToDictionary(a => a.Key, a => a.Count);

				var q =
					from m in members
					where m.attrs.Count > 0
					select new { m, w = m.attrs.Sum(aa => attrWeight[aa.name]) } into m
					orderby m.w descending
					select m.m;

				var attrs = new List<string>();

				foreach (var m in q)
				{
					var list = m.attrs.Select(a => a.name).ToList();

					if (attrs.Count == 0)
						attrs.AddRange(list);
					else
					{
						for (var i = 0; i < list.Count; i++)
						{
							var nm = list[i];

							if (!attrs.Contains(nm))
							{
								for (var j = i + 1; j < list.Count; j++)
								{
									var idx = attrs.IndexOf(list[j]);

									if (idx >= 0)
									{
										attrs.Insert(idx, nm);
										break;
									}
								}
							}

							if (!attrs.Contains(nm))
								attrs.Add(nm);
						}
					}
				}

				var mms = members.Select(m =>
				{
					var arr = new Attribute[attrs.Count];

					foreach (var a in m.attrs)
						arr[attrs.IndexOf(a.name)] = a.a;

					return new { m.m, attrs = arr.ToList() };
				}).ToList();

				var idxs = Enumerable.Range(0, attrs.Count).Select(_ => new List<int>()).ToList();

				for (var i = 0; i < mms.Count; i++)
					for (var j = 0; j < mms[i].attrs.Count; j++)
						if (mms[i].attrs[j] != null)
							idxs[j].Add(i);

				var toRemove = new List<int>();

				for (int i = 1; i < idxs.Count; i++)
				{
					for (int j = 0; j < i; j++)
					{
						if (idxs[j] == null)
							continue;

						if (idxs[i].Intersect(idxs[j]).Count() == 0)
						{
							foreach (var m in mms)
							{
								if (m.attrs[i] != null)
								{
									m.attrs[j] = m.attrs[i];
									m.attrs[i] = null;
								}
							}

							idxs[j].AddRange(idxs[i]);
							idxs[i] = null;
							toRemove.Add(i);
							break;
						}
					}

				}

				foreach (var n in toRemove.OrderByDescending(i => i))
					foreach (var m in mms)
						m.attrs.RemoveAt(n);

				var lens = new int[attrs.Count - toRemove.Count];

				foreach (var m in mms)
				{
					for (var i = 0; i < m.attrs.Count; i++)
					{
						var a = m.attrs[i];

						if (a != null)
						{
							var len = a.Name.Length;

							if (a.Parameters.Count >= 0)
								len += a.Parameters.Sum(p => 2 + p.Length);

							lens[i] = Math.Max(lens[i], len);
						}
					}
				}

				foreach (var m in allMembers)
				{
					if (!(m is MemberGroup))
						m.BeginConditional(tt, IsCompact);

					foreach (var c in m.Comment)
						WriteComment(tt, c);

					if (attrs.Count > 0)
					{
						var ma = mms.First(mr => mr.m == m);

						if (m.Attributes.Count > 0)
						{
							tt.Write("[");

							for (var i = 0; i < ma.attrs.Count; i++)
							{
								var a = ma.attrs[i];

								if (a == null)
								{
									tt.WriteSpaces(lens[i]);
									if (i + 1 < ma.attrs.Count)
										tt.Write("  ");
								}
								else
								{
									var len = tt.GenerationEnvironment.Length;
									a.Render(tt);
									len = (tt.GenerationEnvironment.Length - len);

									var commaAdded = false;

									for (var j = i + 1; j < ma.attrs.Count; j++)
									{
										if (ma.attrs[j] != null)
										{
											SkipSpacesAndInsert(tt, ", ");
											commaAdded = true;
											break;
										}
									}

									if (i + 1 < ma.attrs.Count && !commaAdded)
										tt.Write("  ");

									tt.WriteSpaces(lens[i] - len);
								}
							}

							tt.Write("] ");
						}
						else
						{
							tt.WriteSpaces(lens.Sum() + ma.attrs.Count * 2 + 1);
						}
					}

					m.Render(tt, true);

					if (!IsCompact)
						tt.WriteLine("");

					if (!(m is MemberGroup))
						m.EndConditional(tt, IsCompact);
				}
			}
		}
		else
		{
			foreach (var cm in Members)
			{
				if (cm is MemberBase)
				{
					var m = (MemberBase)cm;

					if (!(m is MemberGroup))
						m.BeginConditional(tt, IsCompact);

					foreach (var c in m.Comment)
						WriteComment(tt, c);

					if (m.Attributes.Count > 0)
					{
						var q =
							from a in m.Attributes
							group a by a.Conditional ?? "";

						foreach (var g in q)
						{
							if (g.Key.Length > 0)
							{
								tt.RemoveSpace();
								tt.WriteLine("#if " + g.Key);
							}

							var attrs = g.ToList();

							var aa = attrs.Where(a => !a.IsSeparated).ToList();

							if (aa.Count > 0)
							{
								tt.Write("[");

								for (var i = 0; i < aa.Count; i++)
								{
									if (i > 0) tt.Write(", ");
									aa[i].Render(tt);
								}

								tt.WriteLine("]");
							}

							aa = attrs.Where(a => a.IsSeparated).ToList();

							foreach (var a in aa)
							{
								tt.Write("[");
								a.Render(tt);
								tt.WriteLine("]");
							}

							if (g.Key.Length > 0)
							{
								tt.RemoveSpace();
								tt.WriteLine("#endif");
							}
						}
					}

					m.Render(tt, false);

					if (m.InsertBlankLineAfter)
						tt.WriteLine("");

					if (!(m is MemberGroup))
						m.EndConditional(tt, IsCompact);
				}
				else if (cm is TypeBase)
				{
					var t = (TypeBase)cm;

					t.Render(tt);
					tt.WriteLine("");
				}
			}
		}

		tt.Trim();

		EndConditional(tt, isCompact);

		if (!string.IsNullOrEmpty(Region))
		{
			tt.WriteLine("");
			EndRegion(tt);
		}
	}

	public override IEnumerable<ITree> GetNodes() { return Members; }

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<GeneratedTextTransformation,Field> WriteField = (tt,f) =>
{
	var am = f.AccessModifier.ToString().ToLower();
	var mdf =
		(f.IsStatic   ? " static"   : "") +
		(f.IsReadonly ? " readonly" : "") ;

	tt.Write("{0}{1}{2}{3} {4}{5} {6}",
		am,            LenDiff(f.AccessModifierLen, am),
		mdf,           LenDiff(f.ModifierLen,       mdf),
		f.BuildType(), LenDiff(f.TypeLen,           f.BuildType()),
		f.Name);

	if (f.InitValue != null)
	{
		tt.Write(" = {0}", f.InitValue);
	}

	tt.Write(";");

	if (!string.IsNullOrEmpty(f.EndLineComment))
	{
		tt.WriteSpaces(f.NameLen - f.Name.Length + f.BodyLen + f.ParamLen - 1);
		tt.Write(" ");
		WriteComment(tt, " " + f.EndLineComment);
	}
	else
		tt.WriteLine("");
};

public partial class Field : MemberBase
{
	public bool   IsStatic;
	public bool   IsReadonly;
	public string InitValue;

	public Field()
	{
	}

	public Field(ModelType type, string name)
	{
		TypeBuilder = () => type.ToTypeName();
		Name = name;
	}

	public Field(Func<string> typeBuilder, string name)
	{
		TypeBuilder = typeBuilder;
		Name = name;
	}

	public override int CalcModifierLen()
	{
		return
			(IsStatic   ? " static".  Length : 0) +
			(IsReadonly ? " readonly".Length : 0) ;
	}

	public override int  CalcBodyLen() { return InitValue == null ? 1 : 4 + InitValue.Length; }

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteField(tt, this);
	}
}

static Action<GeneratedTextTransformation,Event> WriteEvent = (tt,m) =>
{
	var am  = m.AccessModifier.ToString().ToLower();
	var mdf =
		(m.IsStatic  ? " static"  : "") +
		(m.IsVirtual ? " virtual" : "") +
		" event";

	tt.Write("{0}{1}{2}{3} {4}{5} {6};",
		am,            LenDiff(m.AccessModifierLen, am),
		mdf,           LenDiff(m.ModifierLen,       mdf),
		m.BuildType(), LenDiff(m.TypeLen,           m.BuildType()),
		m.Name);

	if (!string.IsNullOrEmpty(m.EndLineComment))
	{
		tt.WriteSpaces(m.NameLen - m.Name.Length + m.BodyLen + m.ParamLen - 1);
		tt.Write(" ");
		WriteComment(tt, " " + m.EndLineComment);
	}
	else
		tt.WriteLine("");
};

public partial class Event : MemberBase
{
	public bool IsStatic;
	public bool IsVirtual;

	public Event()
	{
	}

	public Event(Type eventType, string name, bool nullable)
	{
		TypeBuilder = () => new ModelType(eventType, nullable).ToTypeName();
		Name = name;
	}

	public Event(string eventType, string name, bool nullable)
	{
		TypeBuilder = () => new ModelType(eventType, true, nullable).ToTypeName();
		Name = name;
	}

	public Event(Func<string> typeBuilder, string name)
	{
		TypeBuilder = typeBuilder;
		Name = name;
	}

	public override int CalcModifierLen()
	{
		return
			(IsStatic  ? " static". Length : 0) +
			(IsVirtual ? " virtual".Length : 0) +
			" event".Length;
	}

	public override int CalcBodyLen() { return 1; }

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteEvent(tt, this);
	}
}

static Action<GeneratedTextTransformation,Property,bool> WriteProperty = (tt,p,compact) =>
{
	var am  = p.AccessModifier == AccessModifier.None ? "" : p.AccessModifier.ToString().ToLower() + " ";
	var mdf = p.IsAbstract ? "abstract " : p.IsVirtual ? "virtual " : p.IsOverride ? "override " : p.IsStatic ? "static " : "";

	tt.Write("{0}{1}{2}{3}{4}{5} {6}",
		am,            LenDiff(p.AccessModifierLen, am),
		mdf,           LenDiff(p.ModifierLen,       mdf),
		p.BuildType(), LenDiff(p.TypeLen,           p.BuildType()),
		p.Name);

	Action writeComment = () =>
	{
		if (!string.IsNullOrEmpty(p.EndLineComment))
		{
			tt.Write(" ");
			WriteComment(tt, " " + p.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	if (p.IsAuto)
	{
		tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

		var len = tt.GenerationEnvironment.Length;

		tt.Write(" { ");

		if (!p.HasGetter)
			tt.Write("private ");
		else if (p.GetterLen == 13)
			tt.Write("        ");
		tt.Write("get; ");

		if (!p.HasSetter)
			tt.Write("private ");
		else if (p.SetterLen == 13)
			tt.Write("        ");
		tt.Write("set; ");

		tt.Write("}");

		if (p.EnforceNotNullable)
			tt.Write(" = null!;");

		if (!string.IsNullOrEmpty(p.EndLineComment))
			tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
		writeComment();
	}
	else
	{
		if (compact)
		{
			tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

			var len = tt.GenerationEnvironment.Length;

			tt.Write(" { ");

			if (p.HasGetter)
			{
				tt.Write("get { ");
				foreach (var t in p.BuildGetBody())
					tt.Write("{0} ", t);
				tt.Write("} ");
			}

			if (p.HasSetter)
			{
				tt.Write("set { ");
				foreach (var t in p.BuildSetBody())
					tt.Write("{0} ", t);
				tt.Write("} ");
			}

			tt.Write("}");

			if (!string.IsNullOrEmpty(p.EndLineComment))
				tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
			writeComment();
		}
		else
		{
			writeComment();

			tt.WriteLine("{");
			tt.PushIndent("\t");

			if (p.HasGetter)
			{
				var getBody = p.BuildGetBody().ToArray();
				if (getBody.Length == 1)
				{
					tt.WriteLine("get {{ {0} }}", getBody[0]);
				}
				else
				{
					tt.WriteLine("get");
					tt.WriteLine("{");
					tt.PushIndent("\t");

					foreach (var t in getBody)
						tt.WriteLine(t);

					tt.PopIndent();
					tt.WriteLine("}");
				}
			}

			if (p.HasSetter)
			{
				var setBody = p.BuildSetBody().ToArray();
				if (setBody.Length == 1)
				{
					tt.WriteLine("set {{ {0} }}", setBody[0]);
				}
				else
				{
					tt.WriteLine("set");
					tt.WriteLine("{");
					tt.PushIndent("\t");

					foreach (var t in setBody)
						tt.WriteLine(t);

					tt.PopIndent();
					tt.WriteLine("}");
				}
			}

			tt.PopIndent();
			tt.WriteLine("}");
		}
	}
};

public partial class Property : MemberBase
{
	public bool         IsAuto    = true;
	public string       InitValue;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsAbstract;
	public bool         IsStatic;
	public bool         HasGetter = true;
	public bool         HasSetter = true;
	public List<Func<IEnumerable<string>>> GetBodyBuilders = new List<Func<IEnumerable<string>>>();
	public List<Func<IEnumerable<string>>> SetBodyBuilders = new List<Func<IEnumerable<string>>>();

	public int GetterLen = 5;
	public int SetterLen = 5;

	public Property()
	{
	}

	public Property(ModelType type, string name, Func<IEnumerable<string>> getBodyBuilder = null, Func<IEnumerable<string>> setBodyBuilder = null)
	{
		TypeBuilder = () => type.ToTypeName();
		Name        = name;

		InitBody(getBodyBuilder, setBodyBuilder);
	}

	public Property(bool enforceNotNullable, Func<string> typeBuilder, string name, Func<IEnumerable<string>> getBodyBuilder = null, Func<IEnumerable<string>> setBodyBuilder = null)
		: this(typeBuilder, name, getBodyBuilder, setBodyBuilder)
	{
		EnforceNotNullable = enforceNotNullable;
	}

	public Property(Func<string> typeBuilder, string name, Func<IEnumerable<string>> getBodyBuilder = null, Func<IEnumerable<string>> setBodyBuilder = null)
	{
		TypeBuilder = typeBuilder;
		Name = name;

		InitBody(getBodyBuilder, setBodyBuilder);
	}

	public override int CalcModifierLen()
	{
		return IsVirtual ? " virtual".Length : 0;
	}

	public override int CalcBodyLen()
	{
		if (IsAuto)
			return 4 + GetterLen + SetterLen; // ' { get; set; }'

		var len = " {".Length;

		if (HasGetter)
		{
			len += " get {".Length;
			foreach (var t in BuildGetBody())
				len += 1 + t.Length;
			len += " }".Length;
		}

		if (HasSetter)
		{
			len += " set {".Length;
			foreach (var t in BuildSetBody())
				len += 1 + t.Length;
			len += " }".Length;
		}

		len += " }".Length;

		return len;
	}

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		if (!IsAuto && HasGetter)
		{
			var getBody = BuildGetBody().ToArray();
			if (getBody.Length == 1)
			{
				var t = getBody[0];

				if (!t.StartsWith("return"))
				{
					t = "return " + t;

					if (!t.EndsWith(";"))
						t += ";";

					GetBodyBuilders.Clear();
					GetBodyBuilders.Add(() => new [] { t });
				}
			}
		}

		WriteProperty(tt, this, isCompact);
	}

	public Property InitBody(Func<IEnumerable<string>> getBodyBuilder = null, Func<IEnumerable<string>> setBodyBuilder = null)
	{
		IsAuto = getBodyBuilder == null && setBodyBuilder == null;

		if (getBodyBuilder != null) GetBodyBuilders.Add(getBodyBuilder);
		if (setBodyBuilder != null) SetBodyBuilders.Add(setBodyBuilder);

		if (!IsAuto)
		{
			HasGetter = getBodyBuilder != null;
			HasSetter = setBodyBuilder != null;
		}

		return this;
	}

	public Property InitGetter(Func<IEnumerable<string>> getBodyBuilder)
	{
		return InitBody(getBodyBuilder, null);
	}

	public IEnumerable<string> BuildGetBody()
	{
		return GetBodyBuilders.SelectMany(builder => builder?.Invoke() ?? Array.Empty<string>());
	}

	public IEnumerable<string> BuildSetBody()
	{
		return SetBodyBuilders.SelectMany(builder => builder?.Invoke() ?? Array.Empty<string>());
	}

	protected internal virtual bool EnforceNotNullable { get; }
}

static Action<GeneratedTextTransformation,Method,bool> WriteMethod = (tt,m,compact) =>
{
	var am1  = m.AccessModifier.ToString().ToLower();
	var len1 = m.AccessModifierLen;
	var am2  = "";
	var len2 = 0;
	var mdf  = m.IsAbstract ? " abstract" : m.IsVirtual ? " virtual" : m.IsOverride ? " override" : m.IsStatic ? " static" : "";
	var mlen = m.ModifierLen;

	if (am1 == "partial" && mdf.Length > 0)
	{
		am2 = " " + am1; len2 = len1 + 1;
		am1 = "";        len1 = 0;
		mdf = mdf.Trim();
		mlen--;
	}

	tt.Write("{0}{1}{2}{3}{4}{5}{6}{7}{8} {9}{10}",
		am1,           LenDiff(len1, am1),
		mdf,           LenDiff(mlen, mdf),
		am2,           LenDiff(len2, am2),
		m.BuildType() == null ? "" : " ",
		m.BuildType(), LenDiff(m.TypeLen,     m.BuildType() ?? ""),
		m.Name,
		m.GenericArguments.Count > 0 ? $"<{string.Join(", ", m.GenericArguments)}>" : string.Empty);

	Action writeComment = () =>
	{
		if (!string.IsNullOrEmpty(m.EndLineComment))
		{
			tt.Write(" ");
			WriteComment(tt, " " + m.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	Action writeParams = () =>
	{
		tt.Write("(");

		for (int i = 0; i < m.ParameterBuilders.Count; i++)
		{
			if (i > 0)
				tt.Write(", ");
			tt.Write(m.ParameterBuilders[i]());
		}

		tt.Write(")");
	};

	if (compact)
	{
		tt.Write(LenDiff(m.NameLen, m.Name));

		var len = tt.GenerationEnvironment.Length;

		writeParams();

		foreach (var s in m.AfterSignature)
		{
			tt.Write(" ");
			tt.Write(s);
		}

		len = tt.GenerationEnvironment.Length - len;

		if (m.IsAbstract || m.AccessModifier == AccessModifier.Partial)
		{
			tt.Write(";");
			len = 0;
		}
		else
		{
			tt.WriteSpaces(m.ParamLen - len);

			len = tt.GenerationEnvironment.Length;

			tt.Write(" {");

			foreach (var t in m.BuildBody())
				tt.Write(" {0}", t);

			tt.Write(" }");
		}

		if (!string.IsNullOrEmpty(m.EndLineComment))
			tt.WriteSpaces(m.BodyLen - (tt.GenerationEnvironment.Length - len));
		writeComment();
	}
	else
	{
		writeParams ();
		writeComment();

		tt.PushIndent("\t");
		foreach (var s in m.AfterSignature)
			tt.WriteLine(s);
		tt.PopIndent();

		tt.WriteLine("{");
		tt.PushIndent("\t");

		foreach (var t in m.BuildBody())
		{
			if (t.Length > 1 && t[0] == '#')
			{
				tt.RemoveSpace();
			}

			tt.WriteLine(t);
		}

		tt.PopIndent();
		tt.WriteLine("}");
	}
};

public partial class Method : MemberBase
{
	public bool         IsAbstract;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsStatic;
	public List<string> GenericArguments        = new List<string>();
	public List<string> AfterSignature          = new List<string>();
	public List<Func<string>> ParameterBuilders = new List<Func<string>>();
	public List<Func<IEnumerable<string>>> BodyBuilders = new List<Func<IEnumerable<string>>>();

	public Method()
	{
	}

	public Method(Func<string> typeBuilder, string name, IEnumerable<Func<string>> parameterBuilders = null, params Func<IEnumerable<string>>[] bodyBuilders)
	{
		TypeBuilder = typeBuilder;
		Name = name;

		if (parameterBuilders  != null) ParameterBuilders.AddRange(parameterBuilders);
		if (bodyBuilders       != null) BodyBuilders.AddRange(bodyBuilders);
	}

	public static Method Create(string type, string name, IEnumerable<string> parameters = null, IEnumerable<string> body = null)
	{
		return new Method(
			() => type,
			name,
			parameters?.Select<string,Func<string>>((string p) => () => p),
			body?.Select<string,Func<IEnumerable<string>>>(p => () => new[] { p }).ToArray());
	}

	public IEnumerable<string> BuildBody()
	{
		return BodyBuilders.SelectMany(builder => builder?.Invoke() ?? Array.Empty<string>());
	}

	public override int CalcModifierLen()
	{
		return
			IsAbstract ? " abstract".Length :
			IsVirtual  ? " virtual".Length  :
			IsStatic   ? " static".Length   : 0;
	}

	public override int CalcBodyLen()
	{
		if (IsAbstract || AccessModifier == AccessModifier.Partial)
			return 1;

		var len = " {".Length;

		foreach (var t in BuildBody())
			len += 1 + t.Length;

		len += " }".Length;

		return len;
	}

	public override int CalcParamLen()
	{
		return ParameterBuilders.Sum(p => p().Length + 2);
	}

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteMethod(tt, this, isCompact);
	}
}

static Action<GeneratedTextTransformation,Attribute> WriteAttribute = (tt,a) =>
{
	tt.Write(a.Name);

	if (a.Parameters.Count > 0)
	{
		tt.Write("(");

		for (var i = 0; i < a.Parameters.Count; i++)
		{
			if (i > 0)
				if (a.Parameters[i - 1].All(c => c == ' '))
					tt.Write("  ");
				else
					SkipSpacesAndInsert(tt, ", ");
			tt.Write(a.Parameters[i]);
		}

		SkipSpacesAndInsert(tt, ")");
	}
};

public partial class Attribute
{
	public string       Name;
	public List<string> Parameters = new List<string>();
	public string       Conditional;
	public bool         IsSeparated;

	public Attribute()
	{
	}

	public Attribute(string name, params string[] ps)
	{
		Name = name;
		Parameters.AddRange(ps);
	}

	public virtual void Render(GeneratedTextTransformation tt)
	{
		WriteAttribute(tt, this);
	}
}

// Helpers.
//

Func<string,string> ToPlural   = s => s + "s";
Func<string,string> ToSingular = s => s;

static string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

public void WriteSpaces(int len)
{
	while (len-- > 0)
		Write(" ");
}

void RemoveSpace()
{
	Write(" ");

	while (GenerationEnvironment.Length > 0 &&
		(GenerationEnvironment[GenerationEnvironment.Length - 1] == ' ' ||
		 GenerationEnvironment[GenerationEnvironment.Length - 1] == '\t'))
		GenerationEnvironment.Length--;
}

public static IEnumerable<ITree> GetTreeNodes(ITree parent)
{
	foreach (var node in parent.GetNodes())
	{
		yield return node;

		foreach (var grandNode in GetTreeNodes(node))
			yield return grandNode;
	}
}

public static ITree FindNode(ITree parent, Func<ITree,bool> func)
{
	foreach (var node in parent.GetNodes())
	{
		if (func(node))
			return node;

		var n = FindNode(node, func);

		if (n != null)
			return n;
	}

	return null;
}

static void SkipSpacesAndInsert(GeneratedTextTransformation tt, string value)
{
	var l = tt.GenerationEnvironment.Length;

	for (; l > 0 && tt.GenerationEnvironment[l - 1] == ' '; l--)
	{
	}

	tt.GenerationEnvironment.Insert(l, value);
}


string ToCamelCase(string name)
{
	var n = 0;

	foreach (var c in name)
	{
		if (char.IsUpper(c))
			n++;
		else
			break;
	}

	if (n == 0)
		return name;

	if (n == name.Length)
		return name.ToLower();

	n = Math.Max(1, n - 1);

	return name.Substring(0, n).ToLower() + name.Substring(n);
}

event Action<Property,string,object> SetPropertyValueAction;

void SetPropertyValue(Property propertyObject, string propertyName, object value)
{
	if (SetPropertyValueAction != null)
		SetPropertyValueAction(propertyObject, propertyName, value);
}

static string ToStringLiteral(string value)
{
	if (value == null)
		return "null";

	var sb = new StringBuilder("\"");

	foreach (var chr in value)
	{
		switch (chr)
		{
			case '\t':     sb.Append("\\t");            break;
			case '\n':     sb.Append("\\n");            break;
			case '\r':     sb.Append("\\r");            break;
			case '\\':     sb.Append("\\\\");           break;
			case '"' :     sb.Append("\\\"");           break;
			case '\0':     sb.Append("\\0");            break;
			case '\u0085':
			case '\u2028':
			case '\u2029':
					 sb.Append($"\\u{(ushort)chr:X4}"); break;
			default: sb.Append(chr);                    break;
		}
	}

	sb.Append('"');

	return sb.ToString();
}

public class ModelType
{
	private readonly IList<ModelType> _arguments = new List<ModelType>();

	public static ModelType Create<TType>(bool referenceNullable)
	{
		return Create(typeof(TType), referenceNullable);
	}

	public static ModelType Create(Type type, bool referenceNullable)
	{
		if (type.IsArray)
			return Array(Create(type.GetElementType(), false), referenceNullable);

		return new ModelType(type, referenceNullable);
	}

	public static ModelType Array(ModelType elementType, bool referenceNullable)
	{
		return new ModelType(elementType, referenceNullable);
	}

	public ModelType(Type type, bool nullable, params ModelType[] typeArguments)
	{
		if (type.IsConstructedGenericType)
		{
			if (typeArguments != null && typeArguments.Length > 0)
				throw new ArgumentException($"{type} must be open generic type or {typeArguments} should be empty");

			if (!_aliasedTypes.ContainsKey(type))
				_arguments = new List<ModelType>(type.GetGenericArguments().Select(a => new ModelType(a, /* we don't have type info here */ false)));
		}

		Type        = type;
		IsReference = !type.IsValueType;
		IsNullable  = nullable || (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
		if (typeArguments != null && typeArguments.Length > 0)
			_arguments = new List<ModelType>(typeArguments);
	}

	public ModelType(string type, bool referenceType, bool isNullable, params ModelType[] typeArguments)
	{
		TypeName    = type;
		IsReference = referenceType;
		IsNullable  = isNullable;

		if (typeArguments != null && typeArguments.Length > 0)
			_arguments = new List<ModelType>(typeArguments);
	}

	// array constructor
	public ModelType(ModelType elementType, bool isNullable)
	{
		ElementType = elementType;
		IsReference = true;
		IsNullable  = isNullable;
		IsArray     = true;
	}

	public Type      Type        { get; }
	public string    TypeName    { get; }
	public ModelType ElementType { get; }
	public bool      IsReference { get; }
	public bool      IsNullable  { get; }
	public bool      IsArray     { get; }

	public IEnumerable<ModelType> Arguments => _arguments ?? System.Array.Empty<ModelType>();

	private static readonly IDictionary<Type, string> _aliasedTypes = new Dictionary<Type, string>()
	{
		{ typeof(bool),     "bool" },
		{ typeof(byte),     "byte" },
		{ typeof(sbyte),    "sbyte" },
		{ typeof(char),     "char" },
		{ typeof(decimal),  "decimal" },
		{ typeof(double),   "double" },
		{ typeof(float),    "float" },
		{ typeof(int),      "int" },
		{ typeof(uint),     "uint" },
		{ typeof(long),     "long" },
		{ typeof(ulong),    "ulong" },
		{ typeof(object),   "object" },
		{ typeof(short),    "short" },
		{ typeof(ushort),   "ushort" },
		{ typeof(string),   "string" },
		{ typeof(bool?),    "bool?" },
		{ typeof(byte?),    "byte?" },
		{ typeof(sbyte?),   "sbyte?" },
		{ typeof(char?),    "char?" },
		{ typeof(decimal?), "decimal?" },
		{ typeof(double?),  "double?" },
		{ typeof(float?),   "float?" },
		{ typeof(int?),     "int?" },
		{ typeof(uint?),    "uint?" },
		{ typeof(long?),    "long?" },
		{ typeof(ulong?),   "ulong?" },
		{ typeof(short?),   "short?" },
		{ typeof(ushort?),  "ushort?" }
	};

	public string ToTypeName()
	{
		var sb = new StringBuilder();

		if (TypeName != null)
			sb.Append(TypeName);
		else if (Type != null)
			sb.Append(_aliasedTypes.ContainsKey(Type) ? _aliasedTypes[Type] : (Type.Name.Substring(0, Type.Name.IndexOf('`') < 0 ? Type.Name.Length : Type.Name.IndexOf('`'))));
		else
			sb.Append(ElementType.ToTypeName());

		if (_arguments != null && _arguments.Count > 0)
		{
			sb.Append("<");
			sb.Append(string.Join(", ", _arguments.Select(a => a.ToTypeName())));
			sb.Append(">");
		}

		if (IsArray)
			sb.Append("[]");

		if (EnableNullableReferenceTypes && IsReference && IsNullable)
			sb.Append("?");

		return sb.ToString();
	}
}

static bool IsValueTypeDefault(string typeName)
{
	switch (typeName)
	{
		case "bool":
		case "bool?":
		case "char":
		case "char?":
		case "decimal":
		case "decimal?":
		case "int":
		case "int?":
		case "uint":
		case "uint?":
		case "byte":
		case "byte?":
		case "sbyte":
		case "sbyte?":
		case "long":
		case "long?":
		case "ulong":
		case "ulong?":
		case "short":
		case "short?":
		case "ushort":
		case "ushort?":
		case "float":
		case "float?":
		case "double":
		case "double?":
		case "DateTime":
		case "DateTime?":
		case "DateTimeOffset":
		case "DateTimeOffset?":
		case "TimeSpan":
		case "TimeSpan?":
		case "Guid":
		case "Guid?":
		case "SqlHierarchyId":
		case "SqlHierarchyId?":
		case "NpgsqlDate":
		case "NpgsqlDate?":
		case "NpgsqlTimeSpan":
		case "NpgsqlTimeSpan?":
		case "NpgsqlPoint":
		case "NpgsqlPoint?":
		case "NpgsqlLSeg":
		case "NpgsqlLSeg?":
		case "NpgsqlBox":
		case "NpgsqlBox?":
		case "NpgsqlPath":
		case "NpgsqlPath?":
		case "NpgsqlPolygon":
		case "NpgsqlPolygon?":
		case "NpgsqlCircle":
		case "NpgsqlCircle?":
		case "NpgsqlLine":
		case "NpgsqlLine?":
		case "NpgsqlInet":
		case "NpgsqlInet?":
		case "NpgsqlDateTime":
		case "NpgsqlDateTime?":
			return true;
		case "object":
		case "string":
		case "byte[]":
		case "BitArray":
		case "SqlGeography":
		case "SqlGeometry":
		case "PhysicalAddress":
		case "Array":
		case "DataTable":
			return false;
	}

	return typeName.EndsWith("?");
}

#>
