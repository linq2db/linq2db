using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class BuildersGenerator : IIncrementalGenerator
{
	enum BuilderKind { Any, Expr, AnyCall, Call }

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(IsSyntaxBuilder, GetInfos)
			.Where(x => x.attrArgs != null || x.kind == BuilderKind.Any)
			.SelectMany(Expand)
			.Collect();

		context.RegisterImplementationSourceOutput(provider, GenerateCode);
	}

	bool IsSyntaxBuilder(SyntaxNode syntax, CancellationToken _)
	{
		return syntax is AttributeSyntax attr 
			&& GetName(attr.Name) is "BuildsExpression" or "BuildsMethodCall" or "BuildsAny";
	}

	string ToCode(ExpressionSyntax expr)
	{
		// Simplify nameof(..) syntax for better readability,
		// so that identical cases are not duplicated,
		// and to let us sort them properly.
		if (expr is not InvocationExpressionSyntax { Expression: IdentifierNameSyntax { Identifier.Text: "nameof" } } invoke)
			return expr.ToString();

		return invoke.ArgumentList.Arguments[0].Expression switch
		{
			MemberAccessExpressionSyntax member => '"' + member.Name.Identifier.Text + '"',
			IdentifierNameSyntax id => '"' + id.Identifier.Text + '"',
			var unsupported => throw new NotSupportedException("Unsupported nameof value: " + unsupported)
		};
	}

	(string? builder, AttributeArgumentListSyntax? attrArgs, BuilderKind kind) GetInfos(GeneratorSyntaxContext context, CancellationToken _)
	{
		var attr = (AttributeSyntax)context.Node;
		// ClassDeclaration -> AttributeList -> Attribute
		if (attr.Parent?.Parent is not ClassDeclarationSyntax @class) 
			return (null, null, BuilderKind.Any);
		
		// Support for nested classes
		var className = @class.Identifier.Text;
		while (@class.Parent is ClassDeclarationSyntax parentClass)
		{
			@class = parentClass;
			className = $"{@class.Identifier.Text}.{className}";
		}

		return (
			className,
			attr.ArgumentList,			
			GetName(attr.Name) switch 
			{
				"BuildsAny" => BuilderKind.Any,
				"BuildsMethodCall" => BuilderKind.Call,
				_ => BuilderKind.Expr,
			});
	}

	static string? GetName(NameSyntax name)
	{
		return name switch
		{
			SimpleNameSyntax s => s.Identifier.Text,
			QualifiedNameSyntax q => q.Right.Identifier.Text,
			_ => null
		};
	}

	IEnumerable<(string builder, string key, BuilderKind kind, string check)> Expand(
		(string? builder, AttributeArgumentListSyntax? attr, BuilderKind kind) input,
		CancellationToken _)
	{
		if (input.kind == BuilderKind.Any)
			yield return (input.builder!, "", BuilderKind.Any, "CanBuild");
		else
		{
			var expr = input.attr!.Arguments
				.FirstOrDefault(a => a.NameEquals?.Name.Identifier.Text == "CanBuildName")
				?.Expression;
			
			var check = expr != null 
				? ToCode(expr).Trim('"')
				: input.kind == BuilderKind.Call 
				? "CanBuildMethod"
				: "CanBuild";
			
			foreach (var x in input.attr.Arguments)
			{
				if (x.NameEquals != null) continue;
				var key = ToCode(x.Expression);
				yield return (
					input.builder!, 
					key, 
					input.kind == BuilderKind.Expr && key == "ExpressionType.Call" ? BuilderKind.AnyCall : input.kind,
					check);
			}
		}
	}

	void GenerateCode(
		SourceProductionContext context, 
		ImmutableArray<(string builder, string key, BuilderKind kind, string check)> values)
	{
		var sb = new StringBuilder("""
			// <auto-generated />
			#nullable enable

			using LinqToDB.Expressions;
			using System.Diagnostics.CodeAnalysis;
			using System.Linq.Expressions;

			namespace LinqToDB.Linq.Builder;
			
			partial class ExpressionBuilder
			{
				private static class Builder<T> where T: ISequenceBuilder, new()
				{
					public static T Instance = new();
				}

				private static partial ISequenceBuilder? FindBuilderImpl(BuildInfo info, ExpressionBuilder builder)
				{
					var expr = info.Expression = info.Expression.Unwrap();
					switch (expr.NodeType)
					{

			""");
		foreach (var type in values
			.Where(x => x.kind == BuilderKind.Expr)
			.GroupBy(x => x.key))
		{
			sb.Append($$"""
						case {{type.Key}}:

			""");
			foreach (var x in type)
			{
				sb.Append($$"""
							if ({{x.builder}}.{{x.check}}(expr, info, builder))
								return Builder<{{x.builder}}>.Instance;

			""");
			}
			sb.Append("""
							break;


			""");
		}
		sb.Append("""
						case ExpressionType.Call:
							var call = (MethodCallExpression)expr;
							switch (call.Method.Name)
							{

			""");
		foreach (var method in values
			.Where(x => x.kind == BuilderKind.Call)
			.GroupBy(x => x.key)
			.OrderBy(x => x.Key))
		{
			sb.Append($$"""
								case {{method.Key}}:

			""");
			foreach (var x in method)
			{
				sb.Append($$"""
									if ({{x.builder}}.{{x.check}}(call, info, builder))
										return Builder<{{x.builder}}>.Instance;

			""");
			}
			sb.Append("""
									break;


			""");
		}
		sb.Append("""
							}

			""");
		foreach (var (builder, _, _, check) in values.Where(x => x.kind == BuilderKind.AnyCall))
		{
			sb.Append($$"""
							if ({{builder}}.{{check}}(expr, info, builder))
								return Builder<{{builder}}>.Instance;

			""");

		}
		sb.Append("""

							break;
					}


			""");
		foreach (var (builder, _, _, check) in values.Where(x => x.kind == BuilderKind.Any))
		{
			sb.Append($$"""
					if ({{builder}}.{{check}}(info, builder))
						return Builder<{{builder}}>.Instance;

			""");

		}
		sb.Append("""

					return null;
				}
			}
			""");

		context.AddSource("ExpressionBuilder.g.cs", sb.ToString());
	}
}
