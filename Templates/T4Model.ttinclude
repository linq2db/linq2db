<#@ assembly name="System.Core"                   #>
<#@ import namespace="System"                     #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq"                #>
<#+
static Action<GeneratedTextTransformation,string> WriteComment    = (tt,s) => tt.WriteLine("//{0}", s);

Action BeforeGenerateModel = () => {};

bool GenerateProcedureErrors = true;

void GenerateModel()
{
	Model.SetTree();
	
	BeforeGenerateModel();

	if (GenerationEnvironment.Length > 0 && GenerationEnvironment.ToString().Trim().Length == 0)
		GenerationEnvironment.Length = 0;

	WriteComment(this, "---------------------------------------------------------------------------------------------------");
	WriteComment(this, " <auto-generated>");
	WriteComment(this, "    This code was generated by T4Model template for T4 (https://github.com/linq2db/t4models).");
	WriteComment(this, "    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteComment(this, " </auto-generated>");
	WriteComment(this, "---------------------------------------------------------------------------------------------------");

	Model.Render(this);
}

void Trim()
{
	var arr = new[] { '\r', '\n', ' ' };
	while (GenerationEnvironment.Length > 0 && arr.Contains(GenerationEnvironment[GenerationEnvironment.Length - 1]))
		GenerationEnvironment.Length--;

	WriteLine("");
}

static Action<GeneratedTextTransformation,string> WriteUsing = (tt,s) => tt.WriteLine("using {0};", s);

void RenderUsings(List<string> usings)
{
	var q =
		from ns in usings.Distinct()
		group ns by ns.Split('.')[0];

	var groups =
		(from ns in q where ns.Key == "System"                select ns).Concat
		(from ns in q where ns.Key != "System" orderby ns.Key select ns);

	foreach (var gr in groups)
	{
		foreach (var ns in from s in gr orderby s select s)
			WriteUsing(this, ns);

		WriteLine("");
	}

	Trim();
}

// Base data types.
//
public interface ITree
{
	ITree              Parent { get; set; }
	IEnumerable<ITree> GetNodes();
	void               SetTree();
}

ModelSource Model = new ModelSource();

public partial class ModelSource : ITree
{
	public int CurrentNamespace = 0;

	public List<string>    Usings     = new List<String>    { "System"        };
	public List<Namespace> Namespaces = new List<Namespace> { new Namespace() };

	public Namespace      Namespace { get { return Namespaces[CurrentNamespace];       } }
	public List<TypeBase> Types     { get { return Namespaces[CurrentNamespace].Types; } }

	public virtual void Render(GeneratedTextTransformation tt)
	{
		tt.RenderUsings(Usings);
		tt.WriteLine("");

		foreach (var nm in Namespaces)
		{
			nm.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();
	}

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Namespaces; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<GeneratedTextTransformation,string> WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
static Action<GeneratedTextTransformation>        WriteEndNamespace   =  tt    => tt.WriteLine("}");

public partial class Namespace : ITree
{
	public string         Name;
	public List<TypeBase> Types = new List<TypeBase>();

	public virtual void Render(GeneratedTextTransformation tt)
	{
		if (!string.IsNullOrEmpty(Name))
		{
			WriteBeginNamespace(tt, Name);
			tt.PushIndent("\t");
		}

		foreach (var t in Types)
		{
			t.Render(tt);
			tt.WriteLine("");
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Name))
		{
			tt.PopIndent();
			WriteEndNamespace(tt);
		}
	}

	public ITree              Parent     { get; set; }
	public IEnumerable<ITree> GetNodes() { return Types; }

	public void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public interface IClassMember : ITree
{
}

public enum AccessModifier
{
	Public,
	Protected,
	Internal,
	Private,
	Partial
}

public abstract partial class TypeBase : IClassMember
{
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public bool            IsPartial  = true;
	public List<string>    Comment    = new List<string>();
	public List<Attribute> Attributes = new List<Attribute>();

	public abstract void Render(GeneratedTextTransformation tt);

	public          ITree              Parent { get; set; }
	public abstract IEnumerable<ITree> GetNodes();
	public abstract void               SetTree ();
}

static Action<GeneratedTextTransformation,Class> WriteBeginClass = (tt,cl) =>
{
	tt.Write(cl.AccessModifier.ToString().ToLower() + " ");
	if (cl.IsStatic)  tt.Write("static ");
	if (cl.IsPartial) tt.Write("partial ", cl.Name);
	tt.Write("class {0}", cl.Name);

	if (!string.IsNullOrEmpty(cl.BaseClass) || cl.Interfaces.Count > 0)
	{
		var arr = new[] { cl.BaseClass }.Concat(cl.Interfaces)
			.Where(n => n != null)
			.ToArray();
		
		tt.Write(" : ");
		tt.Write(string.Join(", ", arr));
	}

	tt.WriteLine("");
	tt.WriteLine("{");
};

static Action<GeneratedTextTransformation> WriteEndClass = tt => tt.WriteLine("}");

public partial class Class : TypeBase
{
	public string             BaseClass;
	public bool               IsStatic   = false;
	public List<string>       Interfaces = new List<string>();
	public List<IClassMember> Members    = new List<IClassMember>();

	public Class()
	{
	}

	public Class(string name, params IClassMember[] members)
	{
		Name = name;
		Members.AddRange(members);
	}
	
	public override void Render(GeneratedTextTransformation tt)
	{
		foreach (var c in Comment)
			tt.WriteLine("//" + c);

		if (Attributes.Count > 0)
		{
			var aa = Attributes.Where(a => !a.IsSeparated).ToList();
			
			if (aa.Count > 0)
			{
				tt.Write("[");
				
				for (var i = 0; i < aa.Count; i++)
				{
					if (i > 0) SkipSpacesAndInsert(tt, ", ");
					aa[i].Render(tt);
				}

				tt.WriteLine("]");
			}
			
			aa = Attributes.Where(a => a.IsSeparated).ToList();
			
			foreach (var a in aa)
			{
				tt.Write("[");
				a.Render(tt);
				tt.WriteLine("]");
			}
		}
		
		WriteBeginClass(tt, this);
		tt.PushIndent("\t");

		foreach (var cm in Members)
		{
			if (cm is MemberBase)
			{
				var m = (MemberBase)cm;
				
				foreach (var c in m.Comment)
					WriteComment(tt, c);

				if (m.Attributes.Count > 0)
				{
					var q =
						from a in m.Attributes
						group a by a.Conditional ?? "";
					
					foreach (var g in q)
					{
						if (g.Key.Length > 0)
						{
							tt.RemoveSpace();
							tt.WriteLine("#if " + g.Key);
						}
						
						var attrs = g.ToList();
						
						tt.Write("[");

						for (var i = 0; i < attrs.Count; i++)
						{
							if (i > 0) SkipSpacesAndInsert(tt, ", ");
							attrs[i].Render(tt);
						}

						tt.WriteLine("]");

						if (g.Key.Length > 0)
						{
							tt.RemoveSpace();
							tt.WriteLine("#endif");
						}
					}
				}

				m.Render(tt, false);
				if (m.InsertBlankLineAfter)
					tt.WriteLine("");
			}
			else if (cm is TypeBase)
			{
				var t = (TypeBase)cm;
				
				t.Render(tt);
				tt.WriteLine("");
			}
		}

		tt.Trim();

		tt.PopIndent();
		WriteEndClass(tt);
	}

	public override IEnumerable<ITree> GetNodes()
	{
		return Members;
	}

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

public abstract partial class MemberBase : IClassMember
{
	public string          ID;
	public AccessModifier  AccessModifier = AccessModifier.Public;
	public string          Name;
	public string          Type;
	public List<string>    Comment = new List<string>();
	public string          EndLineComment;
	public List<Attribute> Attributes = new List<Attribute>();
	public bool            InsertBlankLineAfter = true;

	public int AccessModifierLen;
	public int ModifierLen;
	public int TypeLen;
	public int NameLen;
	public int ParamLen;
	public int BodyLen;

	public virtual  int  CalcModifierLen() { return 0; }
	public abstract int  CalcBodyLen    ();
	public virtual  int  CalcParamLen   () { return 0; }
	public abstract void Render         (GeneratedTextTransformation tt, bool isCompact);

	public         ITree              Parent     { get; set; }
	public virtual IEnumerable<ITree> GetNodes() { return Enumerable.Empty<ITree>(); }
	public virtual void               SetTree () {}
}

static Action<GeneratedTextTransformation,string> BeginRegion = (tt,s) => { tt.WriteLine("#region {0}", s); };
static Action<GeneratedTextTransformation>        EndRegion   = (tt)   => { tt.WriteLine("#endregion");     };

public partial class MemberGroup : MemberBase
{
	public string             Region;
	public bool               IsCompact;
	public bool               IsPropertyGroup;
	public List<IClassMember> Members = new List<IClassMember>();
	public List<string>       Errors  = new List<string>();

	public override int  CalcBodyLen() { return 0; }
	
	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		if (!string.IsNullOrEmpty(Region))
		{
			BeginRegion(tt, Region);
			tt.WriteLine("");
		}

		if (Errors.Count > 0 && tt.GenerateProcedureErrors)
		{
			tt.RemoveSpace();
			WriteComment(tt, " Use 'GenerateProcedureErrors=false' to disable errors.");
			foreach (var error in Errors)
			{
				tt.Error(error);

				foreach (var e in error.Split('\n'))
				{
					tt.RemoveSpace();
					tt.WriteLine("#error " + e.Trim('\r'));
				}
			}

			tt.WriteLine("");
		}

		if (IsCompact)
		{
			var allMembers = GetTreeNodes(this).OfType<MemberBase>().Where(m => !(m is MemberGroup)).ToList();
			
			if (allMembers.Count > 0)
			{
				int max = allMembers.Max(m => m.AccessModifier.ToString().Length);
				foreach (var m in allMembers)
					m.AccessModifierLen = max;

				max = allMembers.Max(m => m.CalcModifierLen());
				foreach (var m in allMembers)
					m.ModifierLen = max;

				max = allMembers.Max(m => (m.Type ?? "").Length);
				foreach (var m in allMembers)
					m.TypeLen = max;

				var notHasGetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasGetter);
				var notHasSetter = allMembers.OfType<Property>().Any(m => m.IsAuto && !m.HasSetter);

				foreach (var p in allMembers.OfType<Property>())
				{
					if (notHasGetter) p.GetterLen = 13;
					if (notHasSetter) p.SetterLen = 13;
				}
				
				max = allMembers.Max(m => m.Name.Length);
				foreach (var m in allMembers)
					m.NameLen = max;

				max = allMembers.Max(m => m.CalcParamLen());
				foreach (var m in allMembers)
					m.ParamLen = max;
				
				max = allMembers.Max(m => m.CalcBodyLen());
				foreach (var m in allMembers)
					m.BodyLen = max;
				
				var members =
				(
					from m in allMembers
					select new
					{
						m,
						attrs =
						(
							from a in m.Attributes
							group a by a.Name into gr
							select gr.Select((a,i) => new { a, name = a.Name + "." + i }).ToList() into s
							from a in s
							select a
						).ToList()
					}
				).ToList();

				var attrWeight =
				(
					from m in members
					from a in m.attrs
					group a by a.name into gr
					select new { gr.Key, Count = gr.Count() }
				).ToDictionary(a => a.Key, a => a.Count);

				var q =
					from m in members
					where m.attrs.Count > 0
					select new { m, w = m.attrs.Sum(aa => attrWeight[aa.name]) } into m
					orderby m.w descending
					select m.m;

				var attrs = new List<string>();

				foreach (var m in q)
				{
					var list = m.attrs.Select(a => a.name).ToList();

					if (attrs.Count == 0)
						attrs.AddRange(list);
					else
					{
						for (var i = 0; i < list.Count; i++)
						{
							var nm = list[i];
							
							if (!attrs.Contains(nm))
							{
								for (var j = i + 1; j < list.Count; j++)
								{
									var idx = attrs.IndexOf(list[j]);
									
									if (idx >= 0)
									{
										attrs.Insert(idx, nm);
										break;
									}
								}
							}

							if (!attrs.Contains(nm))
								attrs.Add(nm);
						}
					}
				}

				var mms = members.Select(m =>
				{
					var arr = new Attribute[attrs.Count];

					foreach (var a in m.attrs)
						arr[attrs.IndexOf(a.name)] = a.a;

					return new { m.m, attrs = arr.ToList() };
				}).ToList();

				var idxs = Enumerable.Range(0, attrs.Count).Select(_ => new List<int>()).ToList();
				
				for (var i = 0; i < mms.Count; i++)
					for (var j = 0; j < mms[i].attrs.Count; j++)
						if (mms[i].attrs[j] != null)
							idxs[j].Add(i);

				var toRemove = new List<int>();

				for (int i = 1; i < idxs.Count; i++)
				{
					for (int j = 0; j < i; j++)
					{
						if (idxs[j] == null)
							continue;

						if (idxs[i].Intersect(idxs[j]).Count() == 0)
						{
							foreach (var m in mms)
							{
								if (m.attrs[i] != null)
								{
									m.attrs[j] = m.attrs[i];
									m.attrs[i] = null;
								}
							}

							idxs[j].AddRange(idxs[i]);
							idxs[i] = null;
							toRemove.Add(i);
							break;
						}
					}
					
				}

				foreach (var n in toRemove.OrderByDescending(i => i))
					foreach (var m in mms)
						m.attrs.RemoveAt(n);

				var lens = new int[attrs.Count - toRemove.Count];

				foreach (var m in mms)
				{
					for (var i = 0; i < m.attrs.Count; i++)
					{
						var a = m.attrs[i];

						if (a != null)
						{
							var len = a.Name.Length;

							if (a.Parameters.Count >= 0)
								len += a.Parameters.Sum(p => 2 + p.Length);

							lens[i] = Math.Max(lens[i], len);
						}
					}
				}

				foreach (var m in allMembers)
				{
					foreach (var c in m.Comment)
						WriteComment(tt, c);

					if (attrs.Count > 0)
					{
						var ma = mms.First(mr => mr.m == m);

						if (m.Attributes.Count > 0)
						{
							tt.Write("[");

							for (var i = 0; i < ma.attrs.Count; i++)
							{
								var a = ma.attrs[i];

								if (a == null)
								{
									tt.WriteSpaces(lens[i]);
									if (i + 1 < ma.attrs.Count)
										tt.Write("  ");
								}
								else
								{
									var len = tt.GenerationEnvironment.Length;
									a.Render(tt);
									len = (tt.GenerationEnvironment.Length - len);

									var commaAdded = false;
									
									for (var j = i + 1; j < ma.attrs.Count; j++)
									{
										if (ma.attrs[j] != null)
										{
											SkipSpacesAndInsert(tt, ", ");
											commaAdded = true;
											break;
										}
									}

									if (i + 1 < ma.attrs.Count && !commaAdded)
										tt.Write("  ");

									tt.WriteSpaces(lens[i] - len);
								}
							}

							tt.Write("] ");
						}
						else
						{
							tt.WriteSpaces(lens.Sum() + ma.attrs.Count * 2 + 1);
						}
					}

					m.Render(tt, true);

					if (!IsCompact)
						tt.WriteLine("");
				}
			}
		}
		else
		{
			foreach (var cm in Members)
			{
				if (cm is MemberBase)
				{
					var m = (MemberBase)cm;
					
					foreach (var c in m.Comment)
						WriteComment(tt, c);

					if (m.Attributes.Count > 0)
					{
						var q =
							from a in m.Attributes
							group a by a.Conditional ?? "";

						foreach (var g in q)
						{
							if (g.Key.Length > 0)
							{
								tt.RemoveSpace();
								tt.WriteLine("#if " + g.Key);
							}

							var attrs = g.ToList();

							var aa = attrs.Where(a => !a.IsSeparated).ToList();
			
							if (aa.Count > 0)
							{
								tt.Write("[");
				
								for (var i = 0; i < aa.Count; i++)
								{
									if (i > 0) tt.Write(", ");
									aa[i].Render(tt);
								}

								tt.WriteLine("]");
							}
			
							aa = attrs.Where(a => a.IsSeparated).ToList();
			
							foreach (var a in aa)
							{
								tt.Write("[");
								a.Render(tt);
								tt.WriteLine("]");
							}

							if (g.Key.Length > 0)
							{
								tt.RemoveSpace();
								tt.WriteLine("#endif");
							}
						}
					}

					m.Render(tt, false);

					if (m.InsertBlankLineAfter)
						tt.WriteLine("");
				}
				else if (cm is TypeBase)
				{
					var t = (TypeBase)cm;

					t.Render(tt);
					tt.WriteLine("");
				}
			}
		}

		tt.Trim();

		if (!string.IsNullOrEmpty(Region))
		{
			tt.WriteLine("");
			EndRegion(tt);
		}
	}

	public override IEnumerable<ITree> GetNodes() { return Members; }

	public override void SetTree()
	{
		foreach (var ch in GetNodes())
		{
			ch.Parent = this;
			ch.SetTree();
		}
	}
}

static Action<GeneratedTextTransformation,Field> WriteField = (tt,f) =>
{
	var am = f.AccessModifier.ToString().ToLower();
	var mdf =
		(f.IsStatic   ? " static"   : "") +
		(f.IsReadonly ? " readonly" : "") ;

	tt.Write("{0}{1}{2}{3} {4}{5} {6}",
		am,     LenDiff(f.AccessModifierLen, am),
		mdf,    LenDiff(f.ModifierLen,       mdf),
		f.Type, LenDiff(f.TypeLen,           f.Type),
		f.Name);

	if (f.InitValue != null)
	{
		tt.Write(" = {0}", f.InitValue);		
	}
	
	tt.Write(";");
	
	if (!string.IsNullOrEmpty(f.EndLineComment))
	{
		tt.WriteSpaces(f.NameLen - f.Name.Length + f.BodyLen + f.ParamLen - 1);
		tt.Write(" ");
		WriteComment(tt, " " + f.EndLineComment);
	}
	else	
		tt.WriteLine("");
};

public partial class Field : MemberBase
{
	public bool   IsStatic;
	public bool   IsReadonly;
	public string InitValue;

	public Field()
	{
	}
	
	public Field(string type, string name)
	{
		Type = type;
		Name = name;
	}

	public override int CalcModifierLen()
	{
		return
			(IsStatic   ? " static".  Length : 0) +
			(IsReadonly ? " readonly".Length : 0) ;
	}

	public override int  CalcBodyLen() { return InitValue == null ? 1 : 4 + InitValue.Length; }
	
	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteField(tt, this);
	}
}

static Action<GeneratedTextTransformation,Event> WriteEvent = (tt,m) =>
{
	var am  = m.AccessModifier.ToString().ToLower();
	var mdf =
		(m.IsStatic  ? " static"  : "") +
		(m.IsVirtual ? " virtual" : "") +
		" event";

	tt.Write("{0}{1}{2}{3} {4}{5} {6};",
		am,     LenDiff(m.AccessModifierLen, am),
		mdf,    LenDiff(m.ModifierLen,       mdf),
		m.Type, LenDiff(m.TypeLen,           m.Type),
		m.Name);

	if (!string.IsNullOrEmpty(m.EndLineComment))
	{
		tt.WriteSpaces(m.NameLen - m.Name.Length + m.BodyLen + m.ParamLen - 1);
		tt.Write(" ");
		WriteComment(tt, " " + m.EndLineComment);
	}
	else
		tt.WriteLine("");
};

public partial class Event : MemberBase
{
	public bool IsStatic;
	public bool IsVirtual;
	
	public Event()
	{
	}
	
	public Event(string type, string name)
	{
		Type = type;
		Name = name;
	}

	public override int CalcModifierLen()
	{
		return
			(IsStatic  ? " static". Length : 0) +
			(IsVirtual ? " virtual".Length : 0) +
			" event".Length;
	}

	public override int CalcBodyLen() { return 1; }

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteEvent(tt, this);
	}
}

static Action<GeneratedTextTransformation,Property,bool> WriteProperty = (tt,p,compact) =>
{
	var am  = p.AccessModifier.ToString().ToLower();
//	var mdf = p.IsVirtual ? " virtual" : "";
	var mdf = p.IsAbstract ? " abstract" : p.IsVirtual ? " virtual" : p.IsOverride ? " override" : p.IsStatic ? " static" : "";

	tt.Write("{0}{1}{2}{3} {4}{5} {6}",
		am,     LenDiff(p.AccessModifierLen, am),
		mdf,    LenDiff(p.ModifierLen,       mdf),
		p.Type, LenDiff(p.TypeLen,           p.Type),
		p.Name);

	Action writeComment = () =>
	{
		if (!string.IsNullOrEmpty(p.EndLineComment))
		{
			tt.Write(" ");
			WriteComment(tt, " " + p.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	if (p.IsAuto)
	{
		tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

		var len = tt.GenerationEnvironment.Length;

		tt.Write(" { ");

		if (!p.HasGetter)
			tt.Write("private ");
		else if (p.GetterLen == 13)
			tt.Write("        ");
		tt.Write("get; ");

		if (!p.HasSetter)
			tt.Write("private ");
		else if (p.SetterLen == 13)
			tt.Write("        ");
		tt.Write("set; ");

		tt.Write("}");

		if (!string.IsNullOrEmpty(p.EndLineComment))
			tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
		writeComment();
	}
	else
	{
		if (compact)
		{
			tt.Write(LenDiff(p.NameLen + p.ParamLen, p.Name));

			var len = tt.GenerationEnvironment.Length;

			tt.Write(" { ");

			if (p.HasGetter)
			{
				tt.Write("get { ");
				foreach (var t in p.GetBody)
					tt.Write("{0} ", t);
				tt.Write("} ");
			}

			if (p.HasSetter)
			{
				tt.Write("set { ");
				foreach (var t in p.SetBody)
					tt.Write("{0} ", t);
				tt.Write("} ");
			}

			tt.Write("}");

			if (!string.IsNullOrEmpty(p.EndLineComment))
				tt.WriteSpaces(p.BodyLen - (tt.GenerationEnvironment.Length - len));
			writeComment();
		}
		else
		{
			writeComment();

			tt.WriteLine("{");
			tt.PushIndent("\t");

			if (p.HasGetter)
			{
				if (p.GetBody.Count == 1)
				{
					tt.WriteLine("get {{ {0} }}", p.GetBody[0]);
				}
				else
				{
					tt.WriteLine("get");
					tt.WriteLine("{");
					tt.PushIndent("\t");

					foreach (var t in p.GetBody)
						tt.WriteLine(t);
					
					tt.PopIndent();
					tt.WriteLine("}");
				}
			}

			if (p.HasSetter)
			{
				if (p.SetBody.Count == 1)
				{
					tt.WriteLine("set {{ {0} }}", p.SetBody[0]);
				}
				else
				{
					tt.WriteLine("set");
					tt.WriteLine("{");
					tt.PushIndent("\t");

					foreach (var t in p.SetBody)
						tt.WriteLine(t);

					tt.PopIndent();
					tt.WriteLine("}");
				}
			}

			tt.PopIndent();
			tt.WriteLine("}");
		}
	}
};

public partial class Property : MemberBase
{
	public bool         IsAuto    = true;
	public string       InitValue;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsAbstract;
	public bool         IsStatic;
	public bool         HasGetter = true;
	public bool         HasSetter = true;
	public List<string> GetBody   = new List<string>();
	public List<string> SetBody   = new List<string>();

	public int GetterLen = 5;
	public int SetterLen = 5;

	public Property()
	{
	}

	public Property(string type, string name, IEnumerable<string> getBody = null, IEnumerable<string> setBody = null)
	{
		Type = type;
		Name = name;
		
		InitBody(getBody, setBody);
	}

	public override int CalcModifierLen()
	{
		return IsVirtual ? " virtual".Length : 0;
	}

	public override int CalcBodyLen()
	{
		if (IsAuto)
			return 4 + GetterLen + SetterLen; // ' { get; set; }'

		var len = " {".Length;

		if (HasGetter)
		{
			len += " get {".Length;
			foreach (var t in GetBody)
				len += 1 + t.Length;
			len += " }".Length;
		}

		if (HasSetter)
		{
			len += " set {".Length;
			foreach (var t in SetBody)
				len += 1 + t.Length;
			len += " }".Length;
		}

		len += " }".Length;

		return len;
	}

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		if (!IsAuto && HasGetter && GetBody.Count == 1)
		{
			var t = GetBody[GetBody.Count - 1];
			
			if (!t.StartsWith("return"))
			{
				t = "return " + t;
				
				if (!t.EndsWith(";"))
					t += ";";
				
				GetBody[GetBody.Count - 1] = t;
			}
		}
		
		WriteProperty(tt, this, isCompact);
	}
	
	public Property InitBody(IEnumerable<string> getBody = null, IEnumerable<string> setBody = null)
	{
		IsAuto = getBody == null && setBody == null;

		if (getBody != null) GetBody.AddRange(getBody);
		if (setBody != null) SetBody.AddRange(setBody);

		if (!IsAuto)
		{
			HasGetter = getBody != null;
			HasSetter = setBody != null;
		}
		
		return this;
	}
	
	public Property InitGetter(params string[] getBody)
	{
		return InitBody(getBody, null);
	}
}

static Action<GeneratedTextTransformation,Method,bool> WriteMethod = (tt,m,compact) =>
{
	var am1  = m.AccessModifier.ToString().ToLower();
	var len1 = m.AccessModifierLen;
	var am2  = "";
	var len2 = 0;
	var mdf  = m.IsAbstract ? " abstract" : m.IsVirtual ? " virtual" : m.IsOverride ? " override" : m.IsStatic ? " static" : "";
	var mlen = m.ModifierLen;

	if (am1 == "partial" && mdf.Length > 0)
	{
		am2 = " " + am1; len2 = len1 + 1;
		am1 = "";        len1 = 0;
		mdf = mdf.Trim();
		mlen--;
	}

	tt.Write("{0}{1}{2}{3}{4}{5}{6}{7}{8} {9}",
		am1,    LenDiff(len1, am1),
		mdf,    LenDiff(mlen, mdf),
		am2,    LenDiff(len2, am2),
		m.Type == null ? "" : " ",
		m.Type, LenDiff(m.TypeLen,     m.Type ?? ""),
		m.Name);

	Action writeComment = () =>
	{
		if (!string.IsNullOrEmpty(m.EndLineComment))
		{
			tt.Write(" ");
			WriteComment(tt, " " + m.EndLineComment);
		}
		else
			tt.WriteLine("");
	};

	Action writeParams = () =>
	{
		tt.Write("(");

		for (int i = 0; i < m.Parameters.Count; i++)
		{
			if (i > 0)
				tt.Write(", ");
			tt.Write(m.Parameters[i]);
		}

		tt.Write(")");
	};

	if (compact)
	{
		tt.Write(LenDiff(m.NameLen, m.Name));

		var len = tt.GenerationEnvironment.Length;
		
		writeParams();

		foreach (var s in m.AfterSignature)
		{
			tt.Write(" ");
			tt.Write(s);
		}

		len = tt.GenerationEnvironment.Length - len;

		if (m.IsAbstract || m.AccessModifier == AccessModifier.Partial)
		{
			tt.Write(";");
			len = 0;
		}
		else
		{
			tt.WriteSpaces(m.ParamLen - len);

			len = tt.GenerationEnvironment.Length;

			tt.Write(" {");
		
			foreach (var t in m.Body)
				tt.Write(" {0}", t);

			tt.Write(" }");
		}

		if (!string.IsNullOrEmpty(m.EndLineComment))
			tt.WriteSpaces(m.BodyLen - (tt.GenerationEnvironment.Length - len));
		writeComment();
	}
	else
	{
		writeParams ();
		writeComment();

		tt.PushIndent("\t");
		foreach (var s in m.AfterSignature)
			tt.WriteLine(s);
		tt.PopIndent();

		tt.WriteLine("{");
		tt.PushIndent("\t");
		
		foreach (var t in m.Body)
		{
			if (t.Length > 1 && t[0] == '#')
			{
				tt.RemoveSpace();
			}

			tt.WriteLine(t);
		}

		tt.PopIndent();
		tt.WriteLine("}");
	}
};

public partial class Method : MemberBase
{
	public bool         IsAbstract;
	public bool         IsVirtual;
	public bool         IsOverride;
	public bool         IsStatic;
	public List<string> AfterSignature = new List<string>();
	public List<string> Parameters     = new List<string>();
	public List<string> Body           = new List<string>();
	
	public Method()
	{
	}

	public Method(string type, string name, IEnumerable<string> parameters = null, IEnumerable<string> body = null)
	{
		Type = type;
		Name = name;

		if (parameters != null) Parameters.AddRange(parameters);
		if (body       != null) Body.      AddRange(body);
	}

	public override int CalcModifierLen()
	{
		return
			IsAbstract ? " abstract".Length :
			IsVirtual  ? " virtual".Length  :
			IsStatic   ? " static".Length   : 0;
	}

	public override int CalcBodyLen()
	{
		if (IsAbstract || AccessModifier == AccessModifier.Partial)
			return 1;

		var len = " {".Length;

		foreach (var t in Body)
			len += 1 + t.Length;

		len += " }".Length;

		return len;
	}

	public override int CalcParamLen()
	{
		return Parameters.Sum(p => p.Length + 2);
	}

	public override void Render(GeneratedTextTransformation tt, bool isCompact)
	{
		WriteMethod(tt, this, isCompact);
	}
}

static Action<GeneratedTextTransformation,Attribute> WriteAttribute = (tt,a) =>
{
	tt.Write(a.Name);

	if (a.Parameters.Count > 0)
	{
		tt.Write("(");

		for (var i = 0; i < a.Parameters.Count; i++)
		{
			if (i > 0)
				if (a.Parameters[i - 1].All(c => c == ' '))
					tt.Write("  ");
				else
					SkipSpacesAndInsert(tt, ", ");
			tt.Write(a.Parameters[i]);
		}

		SkipSpacesAndInsert(tt, ")");
	}
};

public partial class Attribute
{
	public string       Name;
	public List<string> Parameters = new List<string>();
	public string       Conditional;
	public bool         IsSeparated;

	public Attribute()
	{
	}

	public Attribute(string name, params string[] ps)
	{
		Name = name;
		Parameters.AddRange(ps);
	}

	public virtual void Render(GeneratedTextTransformation tt)
	{
		WriteAttribute(tt, this);
	}
}

// Helpers.
//

Func<string,string> ToPlural   = s => s + "s";
Func<string,string> ToSingular = s => s;

static string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

public void WriteSpaces(int len)
{
	while (len-- > 0)
		Write(" ");
}

void RemoveSpace()
{
	Write(" ");
	
	while (GenerationEnvironment.Length > 0 &&
		(GenerationEnvironment[GenerationEnvironment.Length - 1] == ' ' ||
		 GenerationEnvironment[GenerationEnvironment.Length - 1] == '\t'))
		GenerationEnvironment.Length--;
}

public static IEnumerable<ITree> GetTreeNodes(ITree parent)
{
	foreach (var node in parent.GetNodes())
	{
		yield return node;

		foreach (var grandNode in GetTreeNodes(node))
			yield return grandNode;
	}
}

public static ITree FindNode(ITree parent, Func<ITree,bool> func)
{
	foreach (var node in parent.GetNodes())
	{
		if (func(node))
			return node;

		var n = FindNode(node, func);
		
		if (n != null)
			return n;
	}

	return null;
}

static void SkipSpacesAndInsert(GeneratedTextTransformation tt, string value)
{
	var l = tt.GenerationEnvironment.Length;

	for (; l > 0 && tt.GenerationEnvironment[l - 1] == ' '; l--)
	{
	}

	tt.GenerationEnvironment.Insert(l, value);
}


string ToCamelCase(string name)
{
	var n = 0;

	foreach (var c in name)
	{
		if (char.IsUpper(c))
			n++;
		else
			break;
	}

	if (n == 0)
		return name;

	if (n == name.Length)
		return name.ToLower();

	n = Math.Max(1, n - 1);

	return name.Substring(0, n).ToLower() + name.Substring(n);
}

event Action<Property,string,object> SetPropertyValueAction;

void SetPropertyValue(Property propertyObject, string propertyName, object value)
{
	if (SetPropertyValueAction != null)
		SetPropertyValueAction(propertyObject, propertyName, value);
}
#>
